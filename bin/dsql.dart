import 'dart:async';
import 'dart:io';

import 'package:args/args.dart';
import 'package:strings/strings.dart';
import 'package:path/path.dart' as p;

FutureOr<void> main(List<String> args) async {
  try {
    final parser = ArgParser()
      ..addFlag('help', abbr: 'h', help: 'Show this help message!', negatable: false)
      ..addFlag('generate', abbr: 'g', help: 'Generate the Dart code for the SQL schema!', negatable: false)
      ..addFlag('version', abbr: 'v', help: 'Print the version!', negatable: false)
      ..addOption('output', abbr: 'o', valueHelp: 'Set the output path!');

    final result = parser.parse(args);

    final root = Directory.current;

    final output = result['output'] as String? ?? p.join(root.path, 'lib', 'generated');

    final generate = result['generate'] as bool? ?? false;

    final version = result['version'] as bool? ?? false;

    final help = result['help'] as bool? ?? false;

    if (help) {
      stdout.writeln('''
DSQL CLI - Dart SQL Schema Generator

Usage: dsql [options]

Options:
  -h, --help            Show this help message
  -g, --generate        Generate the Dart code for the SQL schema!
  -v, --version         Print the version
  -o, --output <path>   Set the output path

Example:
  in root of your project create a directory called migrations and put a sql file inside it
  you can call whatever you want, but I recomended to use something like this V1_name_of_file.sql
  this way you can easily organize your migrations by versions!

  Inside the sql file, you need to put an entity name before table script
  Example:
    -- Entity => UserEntity
    CREATE TABLE users (
      id SERIAL PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      email VARCHAR(255) NOT NULL UNIQUE,
      password VARCHAR(255) NOT NULL
    );
  
  This way the generator will use the entity name to generate the classes in dart!

  In the next step, you need to run the generator with the --generate or -g flag
  Example:
    dsql --generate

  And if you want to save the generated code in other path, use the --output or -o flag
  Example:
    dsql --generate --output /path/to/output  
''');
      exit(0);
    }

    if (version) {
      stdout.writeln('DSQL version: 0.0.1 at 2023-09-24 19:15');
      exit(0);
    }

    if (!generate) {
      stdout.writeln('For generating the SQL schema, use the --generate flag!');
      exit(0);
    }

    await generateFile(output);
    exit(0);
  } on Exception catch (e) {
    stdout.writeln('Error: $e');
  }
}

typedef Metadata = ({String type, String name, bool nullable, bool required, bool primaryKey});
typedef Repository = ({String repository, String name});

final tableScriptRegex = RegExp(
  r'^\s*--\s*Entity\s*=>\s*(\w+)\s*\n\s*CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]*?)\);$',
  caseSensitive: false,
  multiLine: true,
);

Future<void> generateFile(String path) async {
  final root = Directory.current;

  final migrations = Directory(p.join(root.path, 'migrations'));

  if (!migrations.existsSync()) {
    stdout.writeln('No migrations directory found!');
    exit(0);
  }

  final files = migrations.listSync(recursive: true).where((file) => file.statSync().type == FileSystemEntityType.file);

  final versions = files.where((file) => p.basename(file.path).startsWith(RegExp(r'^\V[\d]+\_\_(.*).sql$')));

  if (versions.isEmpty) {
    stdout.writeln('No versions found in migrations directory!');
    exit(0);
  }

  final buffer = StringBuffer();

  buffer.writeln('import \'dart:convert\';');

  buffer.writeln('import \'package:postgres/postgres.dart\';');

  buffer.writeln();

  buffer.writeln('// ###########################################');

  buffer.writeln('// Generated by DSQL do not edit by hand!');

  buffer.writeln('// ###########################################');

  buffer.writeln();

  final version = stringNormalize(await File(versions.last.path).readAsString());

  final repositories = <Repository>[];

  final matches = tableScriptRegex.allMatches(version);

  for (final match in matches) {
    final (content, repository) = tableToEntity(match);

    repositories.add(repository);

    buffer.writeln(content);
  }

  buffer.writeln('/// [DSQL] Dart ORM');

  buffer.writeln('class DSQL {');

  buffer.writeln('  late final PostgreSQLConnection _conn;');

  buffer.writeln();

  for (final repository in repositories) {
    buffer.writeln('  late final ${repository.repository} _${repository.repository.toCamelCase(lower: true)};');

    buffer.writeln();

    buffer.writeln('  ${repository.repository} get ${repository.name} => _${repository.repository.toCamelCase(lower: true)};');

    buffer.writeln();
  }

  buffer.writeln('  DSQL(String host, int port, String database, {String? username, String? password, bool useSSL = false}) {');

  buffer.writeln('    _conn = PostgreSQLConnection(host, port, database, username: username, password: password, useSSL: useSSL);');

  for (final repository in repositories) {
    buffer.writeln('    _${repository.repository.toCamelCase(lower: true)} = ${repository.repository}(_conn);');
  }

  buffer.writeln('  }');

  buffer.writeln();

  buffer.writeln('  Future<void> initialize() async {');

  buffer.writeln('      await _conn.open();');

  buffer.writeln('  }');

  buffer.writeln('}');

  final generated = File(p.join(path, 'dsql.dart'));

  if (!generated.existsSync()) generated.createSync(recursive: true);

  await generated.writeAsString(buffer.toString());

  stdout.writeln('Generated file: ${p.join(path, 'dsql.dart')}');

  exit(0);
}

String stringNormalize(String source) {
  final lines = source.split('\n');
  lines.removeWhere((line) => line.trim().isEmpty);
  return lines.join('\n');
}

String snakeToPascalCase(String input) {
  final words = input.split('_');
  final pascalCaseWords = words.map((word) {
    if (word.isEmpty) return '';
    return word[0].toUpperCase() + word.substring(1).toLowerCase();
  });
  return pascalCaseWords.join();
}

(String content, Repository repository) tableToEntity(RegExpMatch match) {
  final entityName = match.group(1) ?? '';
  final tableName = match.group(2) ?? '';
  final lines = match.group(3)?.split('\n') ?? [];

  assert(entityName.isNotEmpty && tableName.isNotEmpty && lines.isNotEmpty, 'Invalid table script, please check your code!');

  final metadatas = <Metadata>[];

  for (final line in lines) {
    if (line.isEmpty) continue;

    final [name, type, ...parts] = line.trim().split(' ');

    final partsJoined = parts.join(' ').toUpperCase();

    metadatas.add(
      (
        type: toDartType(type),
        name: name.toCamelCase(lower: true),
        nullable: !partsJoined.contains(RegExp(r'(NOT NULL|PRIMARY KEY)')),
        required: !partsJoined.contains('DEFAULT'),
        primaryKey: partsJoined.contains('PRIMARY KEY'),
      ),
    );
  }

  final buffer = StringBuffer();

  buffer.writeln('// $entityName');

  buffer.writeln();

  buffer.writeln('class $entityName {');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;
    final type = metadatas[i].type;
    final nullable = metadatas[i].nullable;

    buffer.writeln('  final $type${nullable ? '?' : ''} $name;');
  }

  buffer.writeln();

  buffer.writeln('  const $entityName ({');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;

    buffer.writeln('      required this.$name,');
  }

  buffer.writeln('  });');

  buffer.writeln();

  buffer.writeln('  Map<String, dynamic> toMap() => {');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;

    buffer.writeln('      \'${name.toSnakeCase()}\': $name,');
  }

  buffer.writeln('    };');

  buffer.writeln();

  buffer.writeln('  static $entityName fromMap(Map<String, dynamic> map) => $entityName(');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;
    final type = metadatas[i].type;

    buffer.writeln('      $name: map[\'${name.toSnakeCase()}\'] as $type,');
  }

  buffer.writeln('    );');

  buffer.writeln();

  buffer.writeln('  String toJson() => json.encode(toMap());');

  buffer.writeln();

  buffer.writeln('  static $entityName fromJson(String source) => fromMap(json.decode(source));');

  buffer.writeln();

  buffer.writeln('  static $entityName fromRow(List row) {');

  buffer.writeln('    final [${metadatas.map((e) => e.name).join(', ')}] = row;');

  buffer.writeln();

  buffer.writeln('    return $entityName(');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;

    buffer.writeln('      $name: $name,');
  }

  buffer.writeln('    );');

  buffer.writeln('  }');

  buffer.writeln();

  buffer.writeln('  $entityName copyWith({');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;
    final type = metadatas[i].type;

    buffer.writeln('    $type? $name,');
  }

  buffer.writeln('  }) {');

  buffer.writeln('    return $entityName(');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;

    buffer.writeln('      $name: $name ?? this.$name,');
  }

  buffer.writeln('    );');

  buffer.writeln('  }');

  buffer.writeln();

  buffer.writeln('  @override');

  buffer.writeln('  int get hashCode => ${metadatas.map((e) => '${e.name}.hashCode').join(' ^ ')};');

  buffer.writeln();

  buffer.writeln('  @override');

  buffer.writeln('  bool operator ==(covariant $entityName other) {');

  buffer.writeln('    if (identical(this, other)) return true;');

  buffer.writeln('    if (runtimeType != other.runtimeType) return false;');

  buffer.writeln('    return ${metadatas.map((e) => '${e.name} == other.${e.name}').join(' && ')};');

  buffer.writeln('  }');

  buffer.writeln('}');

  buffer.writeln();

  buffer.writeln('// ${entityName}Repository');

  buffer.writeln();

  buffer.writeln('class ${entityName}Repository {');

  buffer.writeln('  final PostgreSQLConnection conn;');

  buffer.writeln();

  buffer.writeln('  ${entityName}Repository(this.conn);');

  buffer.writeln();

  final requiredMetadatas = metadatas.where((e) => e.required).toList();

  buffer.writeln('  Future<$entityName> create({');

  for (var i = 0; i < requiredMetadatas.length; i++) {
    final name = requiredMetadatas[i].name;

    buffer.writeln('    required $name,');
  }

  buffer.writeln('  }) async {');

  buffer.write('''
    try {
      final create = await conn.query(
        'INSERT INTO $tableName (${requiredMetadatas.map((e) => e.name.toSnakeCase()).join(', ')}) VALUES (${requiredMetadatas.map((e) => '@${e.name}').join(', ')}) RETURNING *',
        substitutionValues: {
          ${requiredMetadatas.map((e) => '\'${e.name}\': ${e.name}').join(', ')}
        },   
      );

      return $entityName.fromRow(create.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
''');

  buffer.writeln('  }');

  buffer.writeln();

  buffer.writeln('  Future<List<$entityName>> findMany({');

  for (var i = 0; i < metadatas.length; i++) {
    final name = metadatas[i].name;
    final type = metadatas[i].type;

    buffer.writeln('    $type? $name,');
  }

  buffer.writeln('  }) async {');

  buffer.write('''
  try {
      PostgreSQLResult select;

      final where = <String, dynamic>{
        ${metadatas.map((e) => 'if (${e.name} != null) \'${e.name.toSnakeCase()}\': ${e.name}').join(', ')}
      };

      if (where.isNotEmpty) {
        select = await conn.query(
          'SELECT * FROM $tableName WHERE \${where.keys.join(' AND ')};',
          substitutionValues: where,
        );
      } else {
        select = await conn.query('SELECT * FROM $tableName;');
      }

      return select.map($entityName.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
''');

  buffer.writeln('  }');

  buffer.writeln();

  if (metadatas.any((e) => e.primaryKey)) {
    final pk = metadatas.firstWhere((e) => e.primaryKey);

    buffer.writeln('  Future<$entityName?> findById(${pk.type} ${pk.name}) async {');

    buffer.write('''
    try {
      final select = await conn.query(
        'SELECT * FROM $tableName WHERE ${pk.name.toSnakeCase()} = @${pk.name}',
        substitutionValues: {
          '${pk.name}': ${pk.name},
        },
      );

      if (select.isEmpty) {
        return null;
      } else {
        return $entityName.fromRow(select.first);
      }
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
''');
  }

  buffer.writeln('  }');

  buffer.writeln('}');

  return (buffer.toString(), (repository: '${entityName}Repository', name: entityName.replaceAll('Entity', '').toLowerCase()));
}

String sqlToRepository() {
  final buffer = StringBuffer();

  return buffer.toString();
}

String toDartType(String type, [bool nullable = false]) => switch (type) {
      var s when (s.startsWith('VARCHAR') || s == 'TEXT' || s == 'UUID') && !nullable => 'String',
      var s when (s.startsWith('VARCHAR') || s == 'TEXT' || s == 'UUID') && nullable => 'String?',
      var s when s == 'BOOLEAN' && !nullable => 'bool',
      var s when s == 'BOOLEAN' && nullable => 'bool?',
      var s when s == 'INTEGER' && !nullable => 'int',
      var s when s == 'INTEGER' && nullable => 'int?',
      var s when s == 'FLOAT' && !nullable => 'double',
      var s when s == 'FLOAT' && nullable => 'double?',
      var s when s == 'TIMESTAMP' && !nullable => 'DateTime',
      var s when s == 'TIMESTAMP' && nullable => 'DateTime?',
      _ => '',
    };
