import 'dart:io';

import 'package:path/path.dart' as p;

import 'dsql_utils.dart';

class DSQLGen {
  static final _tableRegex = RegExp(
    r'^\s*--\s*Entity\s*=>\s*(\w+)\s*\n\s*CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]*?)\);$',
    caseSensitive: false,
    multiLine: true,
  );

  static Future<void> readMigrations(String path, [String? output]) async {
    stdout.writeln('Reading migrations... $path${output != null ? ' -> $output' : ''}');

    final dir = Directory(path);

    if (!dir.existsSync()) {
      stdout.writeln('No migrations directory found!');
      exit(0);
    }

    final files = dir.listSync(recursive: true).where((file) => file.statSync().type == FileSystemEntityType.file);

    final versions = files.where((file) => RegExp(r'^\V[\d]+\_\_(.*).sql$').hasMatch(p.basename(file.path))).toList();

    if (versions.isEmpty) {
      stdout.writeln('No versions found in migrations directory!');
      exit(0);
    }

    versions.sort((a, b) => p.basename(a.path).compareTo(p.basename(b.path)));

    final lastVersion = await File(versions.last.path).readAsString();

    final tablesMatched = _tableRegex.allMatches(lastVersion);

    final tablesPostProcessed = <List<String>>[];

    for (final match in tablesMatched) {
      tablesPostProcessed.add(classGenerator(match));
    }

    final content = generateDSQLClasses(tablesPostProcessed);

    final outputDir = Directory(output ?? p.join(path, '..', 'lib', 'generated'));

    if (!outputDir.existsSync()) {
      outputDir.createSync(recursive: true);
    }

    await File(p.join(outputDir.path, 'dsql.dart')).writeAsString(content);

    await Process.run('dart', ['format', outputDir.path]);

    stdout.writeln('dsql.dart generated successfully${output != null ? 'in $output' : ''}!');

    exit(0);
  }

  static String generateDSQLClasses(List<List<String>> tablesAndRepositories) {
    final buffer = StringBuffer();

    buffer.writeln('import \'dart:io\';');

    buffer.writeln('import \'package:dsql/dsql.dart\';');

    buffer.writeln();

    buffer.writeln('// **************************');

    buffer.writeln('// Generated by DSQL don\'t change by hand!');

    buffer.writeln('// **************************');

    buffer.writeln('');

    for (final tableAndRepository in tablesAndRepositories) {
      final [..., entityName, entityContent] = tableAndRepository;

      buffer.writeln('// $entityName');

      buffer.writeln('');

      buffer.writeln(entityContent);
    }

    for (final tableAndRepository in tablesAndRepositories) {
      final [repositoryName, repositoryContent, ...] = tableAndRepository;

      buffer.writeln('// $repositoryName');

      buffer.writeln('');

      buffer.writeln(repositoryContent);
    }

    buffer.writeln();

    buffer.writeln('class DSQL {');

    buffer.writeln('  late final PostgreSQLConnection _conn;');

    buffer.writeln();

    for (final tableAndRepository in tablesAndRepositories) {
      final [repositoryName, ...] = tableAndRepository;

      buffer.writeln('  late final $repositoryName _${DSQLUtils.toCamelCase(repositoryName)};');

      buffer.writeln();

      buffer.writeln('  $repositoryName get ${DSQLUtils.toCamelCase(repositoryName.replaceAll('Repository', ''))} => _${DSQLUtils.toCamelCase(repositoryName)};');
    }

    buffer.writeln();

    buffer.writeln('  DSQL({required String postgresURL}) {');

    buffer.writeln('''    final uri = Uri.parse(postgresURL);
    final host = uri.host;
    final port = uri.port;
    final database = uri.pathSegments.isNotEmpty ? uri.pathSegments.first : '';
    final userInfo = uri.userInfo.split(':');
    final username = userInfo.isNotEmpty ? Uri.decodeComponent(userInfo[0]) : '';
    final password = userInfo.length > 1 ? Uri.decodeComponent(userInfo[1]) : '';

    _conn = PostgreSQLConnection(
      host,
      port,
      database,
      username: username,
      password: password,
    );''');

    buffer.writeln();

    for (final tableAndRepository in tablesAndRepositories) {
      final [repositoryName, ...] = tableAndRepository;

      buffer.writeln('    _${DSQLUtils.toCamelCase(repositoryName)} = $repositoryName(_conn);');
    }

    buffer.writeln('  }');

    buffer.writeln();

    buffer.writeln('  Future<void> init() async {');

    buffer.writeln('    await _conn.open();');

    buffer.writeln('    final root = Directory.current;');

    buffer.writeln('    final migrations = Directory(DSQLUtils.join(root.path, \'migrations\'));');

    buffer.writeln('    final files = migrations.listSync().where((file) => file.statSync().type == FileSystemEntityType.file);');

    buffer.writeln('    final versions = files.where((file) => RegExp(r\'^\\V[\\d]+\\_\\_(.*).sql\$\').hasMatch(DSQLUtils.basename(file.path))).toList();');

    buffer.writeln('    for (final file in versions) {');

    buffer.writeln('      final version = await File(file.path).readAsString();');

    buffer.writeln('      await _conn.execute(version);');

    buffer.writeln('    }');

    buffer.writeln('  }');

    buffer.writeln();

    buffer.writeln('}');

    return buffer.toString();
  }

  static List<String> classGenerator(RegExpMatch match) {
    final entityName = match.group(1) ?? '';
    final tableName = match.group(2) ?? '';
    final contentLines = match.group(3)?.trim().split('\n') ?? [];

    assert(entityName.isNotEmpty && tableName.isNotEmpty && contentLines.isNotEmpty, 'Invalid table script, please check your code!');

    final params = <Param>[];

    for (final line in contentLines) {
      final [name, type, ...parts] = line.trim().split(' ');

      final partsJoined = parts.join(' ').toUpperCase();

      params.add(
        Param(
          type: sqlDataTypeToDartType(type),
          name: DSQLUtils.toCamelCase(name),
          nullable: !partsJoined.contains(RegExp(r'(NOT NULL|PRIMARY KEY)')),
          required: !partsJoined.contains('DEFAULT'),
          primaryKey: partsJoined.contains('PRIMARY KEY'),
        ),
      );
    }

    final entityBuffer = StringBuffer();

    entityBuffer.writeln('class $entityName {');

    for (var i = 0; i < params.length; i++) {
      final name = params[i].name;
      final type = params[i].type;
      final nullable = params[i].nullable;

      entityBuffer.writeln('    final $type${nullable ? '?' : ''} $name;');
    }

    entityBuffer.writeln();

    entityBuffer.writeln('    const $entityName({');

    for (var i = 0; i < params.length; i++) {
      final name = params[i].name;
      final nullable = params[i].nullable;

      entityBuffer.writeln('        ${nullable ? 'this.$name' : 'required this.$name'},');
    }

    entityBuffer.writeln('    });');

    entityBuffer.writeln();

    entityBuffer.writeln('    Map<String, dynamic> toMap() => {');

    for (var i = 0; i < params.length; i++) {
      final name = params[i].name;

      entityBuffer.writeln('        \'${DSQLUtils.toSnakeCase(name)}\': $name,');
    }

    entityBuffer.writeln('      };');

    entityBuffer.writeln();

    entityBuffer.writeln('    static $entityName fromMap(Map<String, dynamic> map) => $entityName(');

    for (var i = 0; i < params.length; i++) {
      final name = params[i].name;
      final type = params[i].type;

      entityBuffer.writeln('        $name: map[\'${DSQLUtils.toSnakeCase(name)}\'] as $type,');
    }

    entityBuffer.writeln('      );');

    entityBuffer.writeln();

    entityBuffer.writeln('    static $entityName fromRow(List row) {');

    entityBuffer.writeln('      final [${params.map((e) => '${e.type}${e.nullable ? '?' : ''} ${e.name}').join(', ')}] = row;');

    entityBuffer.writeln();

    entityBuffer.writeln('      return $entityName(');

    for (var i = 0; i < params.length; i++) {
      final name = params[i].name;

      entityBuffer.writeln('        $name: $name,');
    }

    entityBuffer.writeln('      );');

    entityBuffer.writeln('    }');

    entityBuffer.writeln();

    entityBuffer.writeln('    @override');

    entityBuffer.writeln('    int get hashCode => ${params.map((e) => '${e.name}.hashCode').join(' ^ ')};');

    entityBuffer.writeln();

    entityBuffer.writeln('    @override');

    entityBuffer.writeln('    bool operator ==(covariant $entityName other) {');

    entityBuffer.writeln('      if (identical(this, other)) return true;');

    entityBuffer.writeln('      if (runtimeType != other.runtimeType) return false;');

    entityBuffer.writeln('      return ${params.map((e) => '${e.name} == other.${e.name}').join(' && ')};');

    entityBuffer.writeln('    }');

    entityBuffer.writeln();

    entityBuffer.writeln('}');

    final repositoryBuffer = StringBuffer();

    final repositoryName = '${entityName.replaceAll('Entity', '')}Repository';

    repositoryBuffer.writeln('class $repositoryName {');

    repositoryBuffer.writeln('  final PostgreSQLConnection conn;');

    repositoryBuffer.writeln();

    repositoryBuffer.writeln('  $repositoryName(this.conn);');

    repositoryBuffer.writeln();

    final requiredParams = params.where((e) => e.required && !e.nullable).toList();

    repositoryBuffer.writeln(createFunScript(entityName, tableName, requiredParams));

    repositoryBuffer.writeln();

    repositoryBuffer.writeln(findManyFunScript(entityName, tableName, params));

    repositoryBuffer.writeln();

    repositoryBuffer.writeln(findOneFunScript(entityName, tableName, params));

    repositoryBuffer.writeln();

    repositoryBuffer.writeln(updateFunScript(entityName, tableName, params));

    repositoryBuffer.writeln();

    repositoryBuffer.writeln(deleteFunScript(entityName, tableName, params));

    repositoryBuffer.writeln('}');

    return [repositoryName, repositoryBuffer.toString(), entityName, entityBuffer.toString()];
  }

  static Type sqlDataTypeToDartType(String type, [bool nullable = false]) => switch (type) {
        var s when (s.startsWith('VARCHAR') || s == 'TEXT' || s == 'UUID') && !nullable => String,
        var s when s == 'BOOLEAN' && !nullable => bool,
        var s when s == 'INTEGER' && !nullable => int,
        var s when s == 'FLOAT' && !nullable => double,
        var s when s == 'TIMESTAMP' && !nullable => DateTime,
        _ => Null,
      };
}

class Param {
  final String name;
  final Type type;
  final bool nullable;
  final bool required;
  final bool primaryKey;

  Param({required this.name, required this.type, required this.nullable, required this.required, required this.primaryKey});
}

String createFunScript(String entityName, String tableName, List<Param> requiredParams) {
  return '''  Future<$entityName> create({
    ${requiredParams.map((e) => 'required ${e.type} ${e.name}').join(', ')},
  }) async {
    try {
      final result = await conn.query(
        'INSERT INTO $tableName (${requiredParams.map((e) => e.name).join(', ')}) VALUES (${requiredParams.map((e) => '@${e.name}').join(', ')}) RETURNING *',
        substitutionValues: {
          ${requiredParams.map((e) => '\'${e.name}\': ${e.name}').join(', ')},
        },
      );

      return $entityName.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }''';
}

String findManyFunScript(String entityName, String tableName, List<Param> params) {
  return '''  Future<List<$entityName>> findMany({
    ${params.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
  }) async {
    try {
      PostgreSQLResult result;

      final filters = <String, Filter>{
        ${params.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      if (filters.isNotEmpty) {
        result = await conn.query(
          'SELECT * FROM $tableName WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' OR ')};',
          substitutionValues: {
            ...filters.map((k, v) => MapEntry(k, v.value)),
          },
        );
      } else {
        result = await conn.query(
          'SELECT * FROM $tableName;',
        );
      }

      return result.map($entityName.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }''';
}

String findOneFunScript(String entityName, String tableName, List<Param> params) {
  final pk = params.any((e) => e.primaryKey) ? params.firstWhere((e) => e.primaryKey) : null;
  final rest = params.where((e) => !e.primaryKey);

  final parameters = pk != null
      ? '${pk.type} ${pk.name}) async {'
      : '''{
    ${rest.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
  }) async {''';

  return '''  Future<$entityName?> findOne($parameters
    try {
      ${pk != null ? '''final result = await conn.query(
        'SELECT * FROM $tableName WHERE ${pk.name} = @${pk.name};',
        substitutionValues: {
          '${pk.name}': ${pk.name},
        },
      );

      return result.isNotEmpty ? $entityName.fromRow(result.first) : null;''' : '''final filters = <String, Filter>{
        ${rest.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final result = await conn.query(
        'SELECT * FROM $tableName WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')};',
        substitutionValues: {
          ...filters.map((k, v) => MapEntry(k, v.value)),
        },
      );

      return result.isNotEmpty ? $entityName.fromRow(result.first) : null;'''}
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }''';
}

String updateFunScript(String entityName, String tableName, List<Param> params) {
  final pk = params.any((e) => e.primaryKey) ? params.firstWhere((e) => e.primaryKey) : null;
  final rest = params.where((e) => !e.primaryKey);

  final parameters = pk != null
      ? '${pk.type} ${pk.name},{${rest.map((e) => '${e.type}? set${DSQLUtils.toPascalCase(e.name)}').join(', ')},}) async {'
      : '''{
    ${rest.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
    ${rest.map((e) => '${e.type}? set${DSQLUtils.toPascalCase(e.name)}').join(', ')},
  }) async {''';

  return '''  Future<$entityName> update($parameters
    try {
      final valuesToUpdate = <String, dynamic>{
        ${rest.map((e) => 'if (set${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': set${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      if (valuesToUpdate.isEmpty) {
        throw Exception('You must provide at least one value to update!');
      }

      ${pk != null ? '''final result = await conn.query(
        'UPDATE $tableName SET \${valuesToUpdate.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} = @\${e.key}').join(', ')} WHERE ${pk.name} = @${pk.name} RETURNING *;',
        substitutionValues: {
          '${pk.name}': ${pk.name},
          ...valuesToUpdate,
        },
      );

      return $entityName.fromRow(result.first);''' : '''final filters = <String, Filter>{
        ${rest.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final result = await conn.query(
        'UPDATE $tableName SET \${valuesToUpdate.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} = @\${e.key}').join(', ')} WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')} RETURNING *;',
        substitutionValues: {
          ...filters.map((k, v) => MapEntry(k, v.value)),
          ...valuesToUpdate,
        },
      );

      return $entityName.fromRow(result.first);'''}
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }''';
}

String deleteFunScript(String entityName, String tableName, List<Param> params) {
  final pk = params.any((e) => e.primaryKey) ? params.firstWhere((e) => e.primaryKey) : null;
  final rest = params.where((e) => !e.primaryKey);

  final parameters = pk != null
      ? '${pk.type} ${pk.name}) async {'
      : '''{
    ${rest.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
  }) async {''';

  return '''  Future<$entityName> delete($parameters
    try {
      ${pk != null ? '''final result = await conn.query(
        'DELETE FROM $tableName WHERE ${pk.name} = @${pk.name} RETURNING *;',
        substitutionValues: {
          '${pk.name}': ${pk.name},
        },
      );

      return $entityName.fromRow(result.first);''' : '''final filters = <String, Filter>{
        ${rest.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final result = await conn.query(
       'DELETE FROM $tableName WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')} RETURNING *;',
        substitutionValues: {
          ...filters.map((k, v) => MapEntry(k, v.value)),
        },
      );

      return $entityName.fromRow(result.first);'''}
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }''';
}
