import 'dart:io';

import 'package:path/path.dart' as p;
import 'package:postgres/postgres.dart';

import 'dsql_utils.dart';
import 'internal/table.dart';

class DSQLGen {
  static final _tableRegex = RegExp(
    r'^\s*--\s*Entity\s*=>\s*(\w+)\s*\n\s*CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]*?)\);$',
    caseSensitive: false,
    multiLine: true,
  );

  static final _propertiesLineRegex = RegExp(r'^(.*)=(.*)$');

  // static final _referencesRegex = RegExp(
  //   r'REFERENCES\s(.*)\s?\((.*)\)',
  //   caseSensitive: false,
  //   multiLine: true,
  // );

  static Future<void> readMigrations(String path, [String? output]) async {
    final dir = Directory(path);

    if (!dir.existsSync()) {
      stdout.writeln('No migrations directory found!');
      exit(0);
    }

    final dotenv = File(p.join(path, '..', '.env'));

    if (!await dotenv.exists()) {
      stdout.writeln('No .env found, you must create a file .env in the application root!');
      exit(0);
    }

    final properties = await dotenv.readAsLines();

    if (properties.isEmpty) {
      stdout.writeln('.env found but no configuration found!');
      exit(0);
    }

    if (!properties.any((line) => _propertiesLineRegex.hasMatch(line) && line.startsWith('DATABASE_URL'))) {
      stdout.writeln('.env found but no DATABASE_URL!');
      exit(0);
    }

    final databaseURL = Uri.parse(properties.firstWhere((line) => _propertiesLineRegex.hasMatch(line) && line.startsWith('DATABASE_URL')).replaceAll('DATABASE_URL=', ''));

    final files = dir.listSync(recursive: true).where((file) => file.statSync().type == FileSystemEntityType.file);

    final versions = files.where((file) => RegExp(r'^\V[\d]+\_\_(.*).sql$').hasMatch(p.basename(file.path))).toList();

    if (versions.isEmpty) {
      stdout.writeln('No versions found in migrations directory!');
      exit(0);
    }

    versions.sort((a, b) => p.basename(a.path).compareTo(p.basename(b.path)));

    final lastVersion = await File(versions.last.path).readAsString();

    stdout.writeln('Migration found... ${p.basename(versions.last.path)}');

    try {
      final PostgreSQLConnection conn = PostgreSQLConnection(
        databaseURL.host,
        databaseURL.port,
        databaseURL.pathSegments.isNotEmpty ? databaseURL.pathSegments.first : '',
        username: databaseURL.userInfo.split(':')[0],
        password: databaseURL.userInfo.split(':')[1],
        useSSL: databaseURL.queryParameters['sslmode'] == 'require',
      );

      await conn.open();

      await conn.execute(lastVersion);

      await conn.close();
    } on PostgreSQLException catch (e) {
      stdout.writeln(e.message);
      exit(0);
    } on Exception catch (e) {
      stdout.writeln(e.toString());
      exit(0);
    }

    final tablesMatched = _tableRegex.allMatches(lastVersion);

    final entityMetadatas = <EntityMetadata>[];

    for (final match in tablesMatched) {
      final entityName = match.group(1) ?? '';
      final tableName = match.group(2) ?? '';
      final content = match.group(3) ?? '';

      entityMetadatas.add(_getEntityMetadata(entityName, tableName, content));
    }

    final content = _generateDSQLClasses(entityMetadatas);

    final outputDir = Directory(output ?? p.join(path, '..', 'lib', 'generated'));

    if (!outputDir.existsSync()) {
      outputDir.createSync(recursive: true);
    }

    await File(p.join(outputDir.path, 'dsql.dart')).writeAsString(content);

    await Process.run('dart', ['format', outputDir.path]);

    stdout.writeln('dsql.dart generated successfully${output != null ? 'in $output' : ''}!');

    exit(0);
  }

  static String _generateDSQLClasses(List<EntityMetadata> metadatas) {
    final buffer = StringBuffer();

    buffer.writeln('import \'dart:io\';');

    buffer.writeln('import \'package:dsql/dsql.dart\';');

    buffer.writeln();

    buffer.writeln('// **************************');

    buffer.writeln('// Generated by DSQL don\'t change by hand!');

    buffer.writeln('// **************************');

    buffer.writeln('');

    for (final metadata in metadatas) {
      buffer.writeln('// ${metadata.entityName}');

      buffer.writeln('');

      buffer.writeln(metadata.entityContent);
    }

    for (final metadata in metadatas) {
      buffer.writeln('// ${metadata.repositoryName}');

      buffer.writeln('');

      buffer.writeln(metadata.repositoryContent);
    }

    buffer.writeln();

    buffer.writeln('class DSQL {');

    buffer.writeln('  late final PostgreSQLConnection _conn;');

    buffer.writeln();

    for (final metadata in metadatas) {
      buffer.writeln('  late final ${metadata.repositoryName} _${DSQLUtils.toCamelCase(metadata.repositoryName)};');

      buffer.writeln();

      buffer.writeln('  ${metadata.repositoryName} get ${DSQLUtils.toCamelCase(metadata.repositoryName.replaceAll('Repository', ''))} => _${DSQLUtils.toCamelCase(metadata.repositoryName)};');
    }

    buffer.writeln();

    buffer.writeln('  DSQL({required String postgresURL}) {');

    buffer.writeln('''    final uri = Uri.parse(postgresURL);
    final host = uri.host;
    final port = uri.port;
    final database = uri.pathSegments.isNotEmpty ? uri.pathSegments.first : '';
    final userInfo = uri.userInfo.split(':');
    final username = userInfo.isNotEmpty ? Uri.decodeComponent(userInfo[0]) : '';
    final password = userInfo.length > 1 ? Uri.decodeComponent(userInfo[1]) : '';

    _conn = PostgreSQLConnection(
      host,
      port,
      database,
      username: username,
      password: password,
    );''');

    buffer.writeln();

    for (final metadata in metadatas) {
      buffer.writeln('    _${DSQLUtils.toCamelCase(metadata.repositoryName)} = ${metadata.repositoryName}(_conn);');
    }

    buffer.writeln('  }');

    buffer.writeln();

    buffer.writeln('  Future<void> init() async {');

    buffer.writeln('    await _conn.open();');

    buffer.writeln('    final root = Directory.current;');

    buffer.writeln('    final migrations = Directory(DSQLUtils.join(root.path, \'migrations\'));');

    buffer.writeln('    final files = migrations.listSync().where((file) => file.statSync().type == FileSystemEntityType.file);');

    buffer.writeln('    final versions = files.where((file) => RegExp(r\'^\\V[\\d]+\\_\\_(.*).sql\$\').hasMatch(DSQLUtils.basename(file.path))).toList();');

    buffer.writeln('    for (final file in versions) {');

    buffer.writeln('      final version = await File(file.path).readAsString();');

    buffer.writeln('      await _conn.execute(version);');

    buffer.writeln('    }');

    buffer.writeln('  }');

    buffer.writeln();

    buffer.writeln('}');

    return buffer.toString();
  }

  static EntityMetadata _getEntityMetadata(String entityName, String tableName, String content) {
    final contentLines = content.trim().split('\n');

    assert(entityName.isNotEmpty && tableName.isNotEmpty && contentLines.isNotEmpty, 'Invalid table script, please check your code!');

    final params = <_Param>[];

    for (final line in contentLines) {
      final [name, type, ...parts] = line.trim().split(' ');

      final partsJoined = parts.join(' ').toUpperCase();

      params.add(
        _Param(
          type: sqlDataTypeToDartType(type),
          name: DSQLUtils.toCamelCase(name),
          nullable: !partsJoined.contains(RegExp(r'(NOT NULL|PRIMARY KEY)')),
          required: !partsJoined.contains('DEFAULT'),
          primaryKey: partsJoined.contains('PRIMARY KEY'),
        ),
      );
    }

    final entityBuffer = StringBuffer();

    entityBuffer.writeln(_entityBuilder(entityName, params));

    final repositoryBuffer = StringBuffer();

    repositoryBuffer.writeln(_repositoryBuilder(entityName, tableName, params));

    return EntityMetadata(
      name: tableName,
      entityName: '${entityName}Entity',
      entityContent: entityBuffer.toString(),
      repositoryName: '${entityName}Repository',
      repositoryContent: repositoryBuffer.toString(),
    );
  }

  static Type sqlDataTypeToDartType(String type, [bool nullable = false]) => switch (type) {
        var s when (s.startsWith('VARCHAR') || s == 'TEXT' || s == 'UUID') && !nullable => String,
        var s when s == 'BOOLEAN' && !nullable => bool,
        var s when s == 'INTEGER' && !nullable => int,
        var s when s == 'FLOAT' && !nullable => double,
        var s when s == 'TIMESTAMP' && !nullable => DateTime,
        _ => Null,
      };
}

class _Param {
  final String name;
  final Type type;
  final bool nullable;
  final bool required;
  final bool primaryKey;

  _Param({required this.name, required this.type, required this.nullable, required this.required, required this.primaryKey});
}

String _entityBuilder(String entity, List<_Param> params) {
  return '''/// An entity created based on .sql file founded on migrations folder
class ${entity}Entity {

  ${params.map((e) => 'final ${e.type}${e.nullable ? '?' : ''} ${DSQLUtils.toCamelCase(e.name)};').join('\n')}

  const ${entity}Entity({${params.map((e) => '${e.nullable ? '' : 'required '}this.${DSQLUtils.toCamelCase(e.name)}').join(', ')},});

  Map<String, dynamic> toMap() {
    return {
      ${params.map((e) => '\'${DSQLUtils.toSnakeCase(e.name)}\': ${DSQLUtils.toCamelCase(e.name)}${e.type == DateTime ? '.millisecondsSinceEpoch' : ''}').join(', ')},
    };
  }

  factory ${entity}Entity.fromMap(Map<String, dynamic> map) {
    return ${entity}Entity(
      ${params.map((e) => '${DSQLUtils.toCamelCase(e.name)}: ${e.type == DateTime ? 'DateTime.fromMillisecondsSinceEpoch(map[\'${DSQLUtils.toSnakeCase(e.name)}\'] as int)' : 'map[\'${DSQLUtils.toSnakeCase(e.name)}\'] as ${e.type}'}').join(', ')},
    );
  }

  factory ${entity}Entity.fromRow(List row) {
    final [${params.map((e) => '${e.type}${e.nullable ? '?' : ''} ${DSQLUtils.toCamelCase(e.name)}').join(', ')},] = row;

    return ${entity}Entity(
      ${params.map((e) => '${DSQLUtils.toCamelCase(e.name)}: ${DSQLUtils.toCamelCase(e.name)}').join(', ')},
    );
  }

  @override
  String toString() {
    return '${entity}Entity(${params.map((e) => '${DSQLUtils.toCamelCase(e.name)}: ${DSQLUtils.toCamelCase(e.name)}').join(', ')})';
  }

  @override
  bool operator ==(covariant ${entity}Entity other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;

    return ${params.map((e) => '${DSQLUtils.toCamelCase(e.name)} == other.${DSQLUtils.toCamelCase(e.name)}').join(' && ')};
  }

  @override
  int get hashCode {
    return ${params.map((e) => '${DSQLUtils.toCamelCase(e.name)}.hashCode').join(' ^ ')};
  }
}''';
}

String _repositoryBuilder(String entity, String table, List<_Param> params) {
  final requiredParams = params.where((e) => e.required && !e.nullable).toList();
  final primaryKey = params.any((e) => e.primaryKey) ? params.firstWhere((e) => e.primaryKey) : null;
  final rest = params.where((e) => !e.primaryKey).toList();

  return '''/// Repository for ${entity}Entity
class ${entity}Repository {
  final PostgreSQLConnection conn;

  const ${entity}Repository(this.conn);

  /// Creates a new [${entity}Entity] in database
  Future<${entity}Entity> create({${requiredParams.map((e) => 'required ${e.type} ${e.name}').join(', ')},}) async {
    try {
      final result = await conn.query(
        'INSERT INTO $table (${requiredParams.map((e) => DSQLUtils.toSnakeCase(e.name)).join(', ')}) VALUES (${requiredParams.map((e) => '@${e.name}').join(', ')}) RETURNING *',
        substitutionValues: {
          ${requiredParams.map((e) => '\'${e.name}\': ${e.name}').join(', ')},
        },
      );

      return ${entity}Entity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a list of [${entity}Entity] from database
  Future<List<${entity}Entity>> findMany({
    ${params.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
    ${entity}OrderBy? orderBy,
    int? limit,
    int? offset,
  }) async {
    try {
      final filters = <String, Filter>{
        ${params.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final orderByOffsetAndLimit = '\${orderBy != null ? 'ORDER BY \${orderBy.param} ' : ''}\${offset != null ? 'OFFSET \$offset ' : ''}\${limit != null ? 'LIMIT \$limit' : ''}';

      PostgreSQLResult result;

      if (filters.isNotEmpty) {
        result = await conn.query(
          'SELECT * FROM $table WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')}\${orderByOffsetAndLimit.isNotEmpty ? ' \$orderByOffsetAndLimit' : ''};',
          substitutionValues: {
            ...filters.map((k, v) => MapEntry(k, v.value)),
          },
        );
      } else {
        result = await conn.query('SELECT * FROM $table\${orderByOffsetAndLimit.isNotEmpty ? ' \$orderByOffsetAndLimit' : ''};');
      }

      return result.map(${entity}Entity.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a single [${entity}Entity] from database if exists
  Future<${entity}Entity?> findOne(${primaryKey != null ? '${primaryKey.type} ${primaryKey.name}' : ''}
  ${primaryKey != null ? '' : '{${rest.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},}'}
  ) async {
    try {
      ${primaryKey != null ? '''final result = await conn.query(
        'SELECT * FROM $table WHERE ${primaryKey.name} = @${primaryKey.name};',
        substitutionValues: {
          '${primaryKey.name}': ${primaryKey.name},
        },
      );

      return result.isNotEmpty ? ${entity}Entity.fromRow(result.first) : null;''' : '''final filters = <String, Filter>{
        ${rest.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final result = await conn.query(
        'SELECT * FROM $table WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')};',
        substitutionValues: {
          ...filters.map((k, v) => MapEntry(k, v.value)),
        },
      );

      return result.isNotEmpty ? ${entity}Entity.fromRow(result.first) : null;'''}
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
  
  /// Updates a [${entity}Entity] in database
  Future<${entity}Entity> update(${primaryKey != null ? '${primaryKey.type} ${primaryKey.name},' : ''}{
  ${primaryKey != null ? '' : '${rest.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},'}
  ${rest.map((e) => '${e.type}? set${DSQLUtils.toPascalCase(e.name)}').join(', ')},
  }) async {
    try {
      final valuesToUpdate = <String, dynamic>{
        ${rest.map((e) => 'if (set${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': set${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

       if (valuesToUpdate.isEmpty) {
        throw Exception('You must provide at least one value to update!');
      }

      ${primaryKey != null ? '''final result = await conn.query(
        'UPDATE $table SET \${valuesToUpdate.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} = @\${e.key}').join(', ')} WHERE ${primaryKey.name} = @${primaryKey.name} RETURNING *;',
        substitutionValues: {
          '${primaryKey.name}': ${primaryKey.name},
          ...valuesToUpdate,
        },
      );

      return ${entity}Entity.fromRow(result.first);''' : '''final filters = <String, Filter>{
        ${rest.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final result = await conn.query(
        'UPDATE ${entity}Entity SET \${valuesToUpdate.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} = @\${e.key}').join(', ')} WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')} RETURNING *;',
        substitutionValues: {
          ...filters.map((k, v) => MapEntry(k, v.value)),
          ...valuesToUpdate,
        },
      );

      return ${entity}Entity.fromRow(result.first);'''}
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Deletes a [${entity}Entity] from database
  Future<${entity}Entity> delete(${primaryKey != null ? '${primaryKey.type} ${primaryKey.name}' : ''}
  ${primaryKey != null ? '' : '{${rest.map((e) => '${DSQLUtils.dartTypeToFilter(e.type)}? where${DSQLUtils.toPascalCase(e.name)}').join(', ')},}'}
  ) async {
    try {
      ${primaryKey != null ? '''final result = await conn.query(
        'DELETE FROM $table WHERE ${primaryKey.name} = @${primaryKey.name} RETURNING *;',
        substitutionValues: {
          '${primaryKey.name}': ${primaryKey.name},
        },
      );

      return ${entity}Entity.fromRow(result.first);''' : '''final filters = <String, Filter>{
        ${rest.map((e) => 'if (where${DSQLUtils.toPascalCase(e.name)} != null) \'${e.name}\': where${DSQLUtils.toPascalCase(e.name)}').join(', ')},
      };

      final result = await conn.query(
       'DELETE FROM $table WHERE \${filters.entries.map((e) => '\${DSQLUtils.toSnakeCase(e.key)} \${e.value.operator} @\${e.key}').join(' AND ')} RETURNING *;',
        substitutionValues: {
          ...filters.map((k, v) => MapEntry(k, v.value)),
        },
      );

      return ${entity}Entity.fromRow(result.first);'''}
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
}

/// Options for sorting when fetching [${entity}Entity's] from database
enum ${entity}OrderBy {
    ${params.map((e) => '${e.name}Asc(\'${e.name.toSnakeCase()} ASC\'),\n${e.name}Desc(\'${e.name.toSnakeCase()} DESC\')').join(', ')};

    final String param;

    const ${entity}OrderBy(this.param);
  }''';
}
