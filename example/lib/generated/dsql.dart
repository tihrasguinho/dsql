// This file is generated by DSQL.
// Do not modify it manually.

import 'package:dsql/dsql.dart';
import 'dart:convert';

part 'entities.dart';

class DSQL {
  late final UsersRepository users;
  late final PostsRepository posts;
  late final LikesRepository likes;
  late final FollowersRepository followers;

  DSQL._(Connection conn, {bool verbose = false}) {
    users = UsersRepository(conn, verbose: verbose);
    posts = PostsRepository(conn, verbose: verbose);
    likes = LikesRepository(conn, verbose: verbose);
    followers = FollowersRepository(conn, verbose: verbose);
  }

  static Future<DSQL> open(String databaseURL, {bool verbose = false}) async {
    final uri = Uri.parse(databaseURL);
    final host = uri.host;
    final port = uri.hasPort ? uri.port : 5432;
    final username = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[0],
    };
    final password = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[1],
    };
    final database = switch (uri.pathSegments.isNotEmpty) {
      true => uri.pathSegments.first,
      false => throw Exception('Database name is required!'),
    };
    final sslMode = switch (uri.queryParameters['sslmode']) {
      'require' => SslMode.require,
      'verify-full' => SslMode.verifyFull,
      'disable' => SslMode.disable,
      _ => SslMode.disable,
    };
    final conn = await Connection.open(
      Endpoint(
        host: host,
        port: port,
        username: username,
        password: password,
        database: database,
      ),
      settings: ConnectionSettings(
        sslMode: sslMode,
      ),
    );

    return DSQL._(conn, verbose: verbose);
  }
}

class UsersRepository {
  final Connection _conn;
  final bool verbose;

  const UsersRepository(this._conn, {this.verbose = false});

  AsyncResult<UserEntity, Exception> insertOne({
    required String name,
    required String username,
    required String email,
    required String password,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_users (name, username, email, password) VALUES ($1, $2, $3, $4) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $name, $username, $email, $password');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [name, username, email, password],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<UserEntity>, Exception> insertMany({
    required List<
            ({String name, String username, String email, String password})>
        values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_users (name, username, email, password) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 4)}, \$${1 + 1 + (index * 4)}, \$${2 + 1 + (index * 4)}, \$${3 + 1 + (index * 4)})').join(', ')} RETURNING *;';

      final parameters = values
          .map((v) => [v.name, v.username, v.email, v.password])
          .expand((v) => v)
          .toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      final entities = List<UserEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $name,
              String $username,
              String $email,
              String $password,
              String? $image,
              String? $bio,
              DateTime $createdAt,
              DateTime $updatedAt,
            ] = row as List;

            final entity = UserEntity(
              id: $id,
              name: $name,
              username: $username,
              email: $email,
              password: $password,
              image: $image,
              bio: $bio,
              createdAt: $createdAt,
              updatedAt: $updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<Pagination<UserEntity>, Exception> findMany(
      [FindManyUserParams params = const FindManyUserParams()]) async {
    try {
      final data = await _conn.runTx<Pagination<UserEntity>>(
        (tx) async {
          final offset = switch (params.page != null) {
            false => 0,
            true => params.page! - 1 < 0 ? 0 : params.page! - 1,
          };

          final limit = params.pageSize ?? 10;

          final orderBy = switch (params.orderBy != null) {
            false => null,
            true => params.orderBy,
          };

          final baseQuery =
              'SELECT * FROM tb_users${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''}${orderBy != null ? ' ORDER BY ${orderBy.sql}' : ''} OFFSET $offset LIMIT $limit;';

          final countQuery =
              'SELECT COUNT(*) FROM tb_users${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''};';

          final baseParameters =
              params.wheres.values.map((w) => w.value).toList();

          if (verbose) {
            print('-' * 80);

            print('QUERY: $baseQuery');

            print('PARAMETERS: $baseParameters');

            print('-' * 80);
          }

          final resultBase = await tx.execute(
            baseQuery,
            parameters: baseParameters,
          );

          final resultCount = await tx.execute(
            countQuery,
            parameters: baseParameters,
          );

          final count = resultCount[0][0] as int;

          if (resultBase.isEmpty) {
            await tx.rollback();
            return Pagination<UserEntity>(
              items: [],
              total: 0,
              page: offset,
              pageSize: limit,
              hasNext: false,
              hasPrevious: false,
            );
          }

          final entitiesBase = List<UserEntity>.from(
            resultBase.map(
              (row) {
                final [
                  String id,
                  String name,
                  String username,
                  String email,
                  String password,
                  String? image,
                  String? bio,
                  DateTime createdAt,
                  DateTime updatedAt,
                ] = row as List;

                return UserEntity(
                  id: id,
                  name: name,
                  username: username,
                  email: email,
                  password: password,
                  image: image,
                  bio: bio,
                  createdAt: createdAt,
                  updatedAt: updatedAt,
                );
              },
            ),
          );

          if (params.includePosts != null) {
            for (var i = 0; i < entitiesBase.length; i++) {
              final entity = entitiesBase[i];

              final joinedWheres = <String, Where>{
                if (params.includePosts?.wheres.isNotEmpty ?? false)
                  ...params.includePosts!.wheres,
                'user_id': Where.eq(entity.id),
              };

              final joinedOffset = switch (params.includePosts?.page != null) {
                false => 0,
                true => params.includePosts!.page! - 1 == 0
                    ? 0
                    : params.includePosts!.page! - 1,
              };

              final joinedLimit = params.includePosts?.pageSize ?? 10;

              final joinedOrderBy =
                  switch (params.includePosts?.orderBy != null) {
                false => null,
                true => params.includePosts!.orderBy,
              };

              final joinedQuery =
                  'SELECT * FROM tb_posts WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}${joinedOrderBy != null ? ' ORDER BY ${joinedOrderBy.sql}' : ''} OFFSET $joinedOffset LIMIT $joinedLimit';

              final joinedParameters =
                  joinedWheres.values.map((w) => w.value).toList();

              final joinedCountQuery =
                  switch (params.includePosts?.withCount ?? false) {
                false => null,
                true =>
                  'SELECT COUNT(*) FROM tb_posts WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}',
              };

              if (verbose) {
                print('-' * 80);

                print('QUERY: $joinedQuery');

                if (joinedCountQuery != null) {
                  print('COUNT QUERY: $joinedCountQuery');
                }

                print('PARAMETERS: $joinedParameters');

                print('-' * 80);
              }

              int? postsCount;

              final joinedResult = await tx.execute(
                joinedQuery,
                parameters: joinedParameters,
              );

              if (joinedCountQuery != null) {
                final joinedCountResult = await tx.execute(
                  joinedCountQuery,
                  parameters: joinedParameters,
                );

                if (joinedCountResult.isNotEmpty) {
                  postsCount = joinedCountResult.first.first as int;
                }
              }

              final joinedEntities = List<PostEntity>.from(
                joinedResult.map(
                  (row) {
                    final [
                      String $id,
                      String? $postId,
                      String $content,
                      String $userId,
                      DateTime $createdAt,
                      DateTime $updatedAt,
                    ] = row as List;

                    return PostEntity(
                      id: $id,
                      postId: $postId,
                      content: $content,
                      userId: $userId,
                      createdAt: $createdAt,
                      updatedAt: $updatedAt,
                    );
                  },
                ),
              );

              entitiesBase[i] = entity.copyWith(
                $posts: () => joinedEntities,
                $postsCount: () => postsCount,
              );
            }
          }

          if (params.includeLikes != null) {
            for (var i = 0; i < entitiesBase.length; i++) {
              final entity = entitiesBase[i];

              final joinedWheres = <String, Where>{
                if (params.includeLikes?.wheres.isNotEmpty ?? false)
                  ...params.includeLikes!.wheres,
                'user_id': Where.eq(entity.id),
              };

              final joinedOffset = switch (params.includeLikes?.page != null) {
                false => 0,
                true => params.includeLikes!.page! - 1 == 0
                    ? 0
                    : params.includeLikes!.page! - 1,
              };

              final joinedLimit = params.includeLikes?.pageSize ?? 10;

              final joinedOrderBy =
                  switch (params.includeLikes?.orderBy != null) {
                false => null,
                true => params.includeLikes!.orderBy,
              };

              final joinedQuery =
                  'SELECT * FROM tb_likes WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}${joinedOrderBy != null ? ' ORDER BY ${joinedOrderBy.sql}' : ''} OFFSET $joinedOffset LIMIT $joinedLimit';

              final joinedParameters =
                  joinedWheres.values.map((w) => w.value).toList();

              final joinedCountQuery =
                  switch (params.includeLikes?.withCount ?? false) {
                false => null,
                true =>
                  'SELECT COUNT(*) FROM tb_likes WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}',
              };

              if (verbose) {
                print('-' * 80);

                print('QUERY: $joinedQuery');

                if (joinedCountQuery != null) {
                  print('COUNT QUERY: $joinedCountQuery');
                }

                print('PARAMETERS: $joinedParameters');

                print('-' * 80);
              }

              int? likesCount;

              final joinedResult = await tx.execute(
                joinedQuery,
                parameters: joinedParameters,
              );

              if (joinedCountQuery != null) {
                final joinedCountResult = await tx.execute(
                  joinedCountQuery,
                  parameters: joinedParameters,
                );

                if (joinedCountResult.isNotEmpty) {
                  likesCount = joinedCountResult.first.first as int;
                }
              }

              final joinedEntities = List<LikeEntity>.from(
                joinedResult.map(
                  (row) {
                    final [
                      String $id,
                      String $postId,
                      String $userId,
                      DateTime $createdAt,
                    ] = row as List;

                    return LikeEntity(
                      id: $id,
                      postId: $postId,
                      userId: $userId,
                      createdAt: $createdAt,
                    );
                  },
                ),
              );

              entitiesBase[i] = entity.copyWith(
                $likes: () => joinedEntities,
                $likesCount: () => likesCount,
              );
            }
          }

          if (params.includeFollowers != null) {
            for (var i = 0; i < entitiesBase.length; i++) {
              final entity = entitiesBase[i];

              final joinedWheres = <String, Where>{
                if (params.includeFollowers?.wheres.isNotEmpty ?? false)
                  ...params.includeFollowers!.wheres,
                'follower_id': Where.eq(entity.id),
              };

              final joinedOffset =
                  switch (params.includeFollowers?.page != null) {
                false => 0,
                true => params.includeFollowers!.page! - 1 == 0
                    ? 0
                    : params.includeFollowers!.page! - 1,
              };

              final joinedLimit = params.includeFollowers?.pageSize ?? 10;

              final joinedOrderBy =
                  switch (params.includeFollowers?.orderBy != null) {
                false => null,
                true => params.includeFollowers!.orderBy,
              };

              final joinedQuery =
                  'SELECT * FROM tb_followers WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}${joinedOrderBy != null ? ' ORDER BY ${joinedOrderBy.sql}' : ''} OFFSET $joinedOffset LIMIT $joinedLimit';

              final joinedParameters =
                  joinedWheres.values.map((w) => w.value).toList();

              final joinedCountQuery =
                  switch (params.includeFollowers?.withCount ?? false) {
                false => null,
                true =>
                  'SELECT COUNT(*) FROM tb_followers WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}',
              };

              if (verbose) {
                print('-' * 80);

                print('QUERY: $joinedQuery');

                if (joinedCountQuery != null) {
                  print('COUNT QUERY: $joinedCountQuery');
                }

                print('PARAMETERS: $joinedParameters');

                print('-' * 80);
              }

              int? followersCount;

              final joinedResult = await tx.execute(
                joinedQuery,
                parameters: joinedParameters,
              );

              if (joinedCountQuery != null) {
                final joinedCountResult = await tx.execute(
                  joinedCountQuery,
                  parameters: joinedParameters,
                );

                if (joinedCountResult.isNotEmpty) {
                  followersCount = joinedCountResult.first.first as int;
                }
              }

              final joinedEntities = List<FollowerEntity>.from(
                joinedResult.map(
                  (row) {
                    final [
                      String $id,
                      String $followerId,
                      String $followingId,
                      DateTime $createdAt,
                    ] = row as List;

                    return FollowerEntity(
                      id: $id,
                      followerId: $followerId,
                      followingId: $followingId,
                      createdAt: $createdAt,
                    );
                  },
                ),
              );

              entitiesBase[i] = entity.copyWith(
                $followers: () => joinedEntities,
                $followersCount: () => followersCount,
              );
            }
          }

          if (params.includeFollowing != null) {
            for (var i = 0; i < entitiesBase.length; i++) {
              final entity = entitiesBase[i];

              final joinedWheres = <String, Where>{
                if (params.includeFollowing?.wheres.isNotEmpty ?? false)
                  ...params.includeFollowing!.wheres,
                'following_id': Where.eq(entity.id),
              };

              final joinedOffset =
                  switch (params.includeFollowing?.page != null) {
                false => 0,
                true => params.includeFollowing!.page! - 1 == 0
                    ? 0
                    : params.includeFollowing!.page! - 1,
              };

              final joinedLimit = params.includeFollowing?.pageSize ?? 10;

              final joinedOrderBy =
                  switch (params.includeFollowing?.orderBy != null) {
                false => null,
                true => params.includeFollowing!.orderBy,
              };

              final joinedQuery =
                  'SELECT * FROM tb_followers WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}${joinedOrderBy != null ? ' ORDER BY ${joinedOrderBy.sql}' : ''} OFFSET $joinedOffset LIMIT $joinedLimit';

              final joinedParameters =
                  joinedWheres.values.map((w) => w.value).toList();

              final joinedCountQuery =
                  switch (params.includeFollowing?.withCount ?? false) {
                false => null,
                true =>
                  'SELECT COUNT(*) FROM tb_followers WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}',
              };

              if (verbose) {
                print('-' * 80);

                print('QUERY: $joinedQuery');

                if (joinedCountQuery != null) {
                  print('COUNT QUERY: $joinedCountQuery');
                }

                print('PARAMETERS: $joinedParameters');

                print('-' * 80);
              }

              int? followingCount;

              final joinedResult = await tx.execute(
                joinedQuery,
                parameters: joinedParameters,
              );

              if (joinedCountQuery != null) {
                final joinedCountResult = await tx.execute(
                  joinedCountQuery,
                  parameters: joinedParameters,
                );

                if (joinedCountResult.isNotEmpty) {
                  followingCount = joinedCountResult.first.first as int;
                }
              }

              final joinedEntities = List<FollowerEntity>.from(
                joinedResult.map(
                  (row) {
                    final [
                      String $id,
                      String $followerId,
                      String $followingId,
                      DateTime $createdAt,
                    ] = row as List;

                    return FollowerEntity(
                      id: $id,
                      followerId: $followerId,
                      followingId: $followingId,
                      createdAt: $createdAt,
                    );
                  },
                ),
              );

              entitiesBase[i] = entity.copyWith(
                $following: () => joinedEntities,
                $followingCount: () => followingCount,
              );
            }
          }

          return Pagination<UserEntity>(
            items: entitiesBase,
            total: entitiesBase.length,
            page: offset,
            pageSize: limit,
            hasNext: (offset + 1) * limit > count,
            hasPrevious: (offset + 1) > 0,
          );
        },
      );

      return Success(data);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findOne({
    Where? id,
    Where? name,
    Where? username,
    Where? email,
    Where? password,
    Where? image,
    Where? bio,
    Where? createdAt,
    Where? updatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (name != null) 'name': name,
        if (username != null) 'username': username,
        if (email != null) 'email': email,
        if (password != null) 'password': password,
        if (image != null) 'image': image,
        if (bio != null) 'bio': bio,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_users WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('UserEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_users WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByUsername(String username) async {
    try {
      final query = r'SELECT * FROM tb_users WHERE username = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $username');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [username],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByEmail(String email) async {
    try {
      final query = r'SELECT * FROM tb_users WHERE email = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $email');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [email],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> updateOne({
    Where? whereId,
    Where? whereName,
    Where? whereUsername,
    Where? whereEmail,
    Where? wherePassword,
    Where? whereImage,
    Where? whereBio,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
    String? setName,
    String? setUsername,
    String? setEmail,
    String? setPassword,
    String? setImage,
    String? setBio,
    DateTime? setCreatedAt,
    DateTime? setUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereName != null) 'name': whereName,
        if (whereUsername != null) 'username': whereUsername,
        if (whereEmail != null) 'email': whereEmail,
        if (wherePassword != null) 'password': wherePassword,
        if (whereImage != null) 'image': whereImage,
        if (whereBio != null) 'bio': whereBio,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setName != null) 'name': setName,
        if (setUsername != null) 'username': setUsername,
        if (setEmail != null) 'email': setEmail,
        if (setPassword != null) 'password': setPassword,
        if (setImage != null) 'image': setImage,
        if (setBio != null) 'bio': setBio,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
        if (setUpdatedAt != null) 'updated_at': setUpdatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_users SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> deleteOne({
    Where? whereId,
    Where? whereName,
    Where? whereUsername,
    Where? whereEmail,
    Where? wherePassword,
    Where? whereImage,
    Where? whereBio,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereName != null) 'name': whereName,
        if (whereUsername != null) 'username': whereUsername,
        if (whereEmail != null) 'email': whereEmail,
        if (wherePassword != null) 'password': wherePassword,
        if (whereImage != null) 'image': whereImage,
        if (whereBio != null) 'bio': whereBio,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_users WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class FindManyUserParams {
  final Where? whereId;
  final Where? whereName;
  final Where? whereUsername;
  final Where? whereEmail;
  final Where? wherePassword;
  final Where? whereImage;
  final Where? whereBio;
  final Where? whereCreatedAt;
  final Where? whereUpdatedAt;
  final IncludeUserPosts? includePosts;
  final IncludeUserLikes? includeLikes;
  final IncludeUserFollowers? includeFollowers;
  final IncludeUserFollowing? includeFollowing;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;

  const FindManyUserParams({
    this.whereId,
    this.whereName,
    this.whereUsername,
    this.whereEmail,
    this.wherePassword,
    this.whereImage,
    this.whereBio,
    this.whereCreatedAt,
    this.whereUpdatedAt,
    this.includePosts,
    this.includeLikes,
    this.includeFollowers,
    this.includeFollowing,
    this.page,
    this.pageSize,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (whereName != null) 'name': whereName!,
        if (whereUsername != null) 'username': whereUsername!,
        if (whereEmail != null) 'email': whereEmail!,
        if (wherePassword != null) 'password': wherePassword!,
        if (whereImage != null) 'image': whereImage!,
        if (whereBio != null) 'bio': whereBio!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt!,
        ...?includePosts?.wheres,
        ...?includeLikes?.wheres,
        ...?includeFollowers?.wheres,
        ...?includeFollowing?.wheres,
      };
}

class IncludeUserPosts {
  final Where? id;
  final Where? postId;
  final Where? content;
  final Where? createdAt;
  final Where? updatedAt;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;
  final bool? withCount;

  const IncludeUserPosts({
    this.id,
    this.postId,
    this.content,
    this.createdAt,
    this.updatedAt,
    this.page,
    this.pageSize,
    this.orderBy,
    this.withCount,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (content != null) 'content': content!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class IncludeUserLikes {
  final Where? id;
  final Where? postId;
  final Where? createdAt;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;
  final bool? withCount;

  const IncludeUserLikes({
    this.id,
    this.postId,
    this.createdAt,
    this.page,
    this.pageSize,
    this.orderBy,
    this.withCount,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class IncludeUserFollowers {
  final Where? id;
  final Where? followingId;
  final Where? createdAt;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;
  final bool? withCount;

  const IncludeUserFollowers({
    this.id,
    this.followingId,
    this.createdAt,
    this.page,
    this.pageSize,
    this.orderBy,
    this.withCount,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (followingId != null) 'following_id': followingId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class IncludeUserFollowing {
  final Where? id;
  final Where? followerId;
  final Where? createdAt;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;
  final bool? withCount;

  const IncludeUserFollowing({
    this.id,
    this.followerId,
    this.createdAt,
    this.page,
    this.pageSize,
    this.orderBy,
    this.withCount,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (followerId != null) 'follower_id': followerId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class PostsRepository {
  final Connection _conn;
  final bool verbose;

  const PostsRepository(this._conn, {this.verbose = false});

  AsyncResult<PostEntity, Exception> insertOne({
    required String content,
    required String userId,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_posts (content, user_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $content, $userId');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [content, userId],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<PostEntity>, Exception> insertMany({
    required List<({String content, String userId})> values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_posts (content, user_id) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 2)}, \$${1 + 1 + (index * 2)})').join(', ')} RETURNING *;';

      final parameters =
          values.map((v) => [v.content, v.userId]).expand((v) => v).toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      final entities = List<PostEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String? $postId,
              String $content,
              String $userId,
              DateTime $createdAt,
              DateTime $updatedAt,
            ] = row as List;

            final entity = PostEntity(
              id: $id,
              postId: $postId,
              content: $content,
              userId: $userId,
              createdAt: $createdAt,
              updatedAt: $updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<Pagination<PostEntity>, Exception> findMany(
      [FindManyPostParams params = const FindManyPostParams()]) async {
    try {
      final data = await _conn.runTx<Pagination<PostEntity>>(
        (tx) async {
          final offset = switch (params.page != null) {
            false => 0,
            true => params.page! - 1 < 0 ? 0 : params.page! - 1,
          };

          final limit = params.pageSize ?? 10;

          final orderBy = switch (params.orderBy != null) {
            false => null,
            true => params.orderBy,
          };

          final baseQuery =
              'SELECT * FROM tb_posts${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''}${orderBy != null ? ' ORDER BY ${orderBy.sql}' : ''} OFFSET $offset LIMIT $limit;';

          final countQuery =
              'SELECT COUNT(*) FROM tb_posts${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''};';

          final baseParameters =
              params.wheres.values.map((w) => w.value).toList();

          if (verbose) {
            print('-' * 80);

            print('QUERY: $baseQuery');

            print('PARAMETERS: $baseParameters');

            print('-' * 80);
          }

          final resultBase = await tx.execute(
            baseQuery,
            parameters: baseParameters,
          );

          final resultCount = await tx.execute(
            countQuery,
            parameters: baseParameters,
          );

          final count = resultCount[0][0] as int;

          if (resultBase.isEmpty) {
            await tx.rollback();
            return Pagination<PostEntity>(
              items: [],
              total: 0,
              page: offset,
              pageSize: limit,
              hasNext: false,
              hasPrevious: false,
            );
          }

          final entitiesBase = List<PostEntity>.from(
            resultBase.map(
              (row) {
                final [
                  String id,
                  String? postId,
                  String content,
                  String userId,
                  DateTime createdAt,
                  DateTime updatedAt,
                ] = row as List;

                return PostEntity(
                  id: id,
                  postId: postId,
                  content: content,
                  userId: userId,
                  createdAt: createdAt,
                  updatedAt: updatedAt,
                );
              },
            ),
          );

          if (params.includeReplies != null) {
            for (var i = 0; i < entitiesBase.length; i++) {
              final entity = entitiesBase[i];

              final joinedWheres = <String, Where>{
                if (params.includeReplies?.wheres.isNotEmpty ?? false)
                  ...params.includeReplies!.wheres,
                'post_id': Where.eq(entity.id),
              };

              final joinedOffset =
                  switch (params.includeReplies?.page != null) {
                false => 0,
                true => params.includeReplies!.page! - 1 == 0
                    ? 0
                    : params.includeReplies!.page! - 1,
              };

              final joinedLimit = params.includeReplies?.pageSize ?? 10;

              final joinedOrderBy =
                  switch (params.includeReplies?.orderBy != null) {
                false => null,
                true => params.includeReplies!.orderBy,
              };

              final joinedQuery =
                  'SELECT * FROM tb_posts WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}${joinedOrderBy != null ? ' ORDER BY ${joinedOrderBy.sql}' : ''} OFFSET $joinedOffset LIMIT $joinedLimit';

              final joinedParameters =
                  joinedWheres.values.map((w) => w.value).toList();

              final joinedCountQuery =
                  switch (params.includeReplies?.withCount ?? false) {
                false => null,
                true =>
                  'SELECT COUNT(*) FROM tb_posts WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}',
              };

              if (verbose) {
                print('-' * 80);

                print('QUERY: $joinedQuery');

                if (joinedCountQuery != null) {
                  print('COUNT QUERY: $joinedCountQuery');
                }

                print('PARAMETERS: $joinedParameters');

                print('-' * 80);
              }

              int? repliesCount;

              final joinedResult = await tx.execute(
                joinedQuery,
                parameters: joinedParameters,
              );

              if (joinedCountQuery != null) {
                final joinedCountResult = await tx.execute(
                  joinedCountQuery,
                  parameters: joinedParameters,
                );

                if (joinedCountResult.isNotEmpty) {
                  repliesCount = joinedCountResult.first.first as int;
                }
              }

              final joinedEntities = List<PostEntity>.from(
                joinedResult.map(
                  (row) {
                    final [
                      String $id,
                      String? $postId,
                      String $content,
                      String $userId,
                      DateTime $createdAt,
                      DateTime $updatedAt,
                    ] = row as List;

                    return PostEntity(
                      id: $id,
                      postId: $postId,
                      content: $content,
                      userId: $userId,
                      createdAt: $createdAt,
                      updatedAt: $updatedAt,
                    );
                  },
                ),
              );

              entitiesBase[i] = entity.copyWith(
                $replies: () => joinedEntities,
                $repliesCount: () => repliesCount,
              );
            }
          }

          if (params.includeLikes != null) {
            for (var i = 0; i < entitiesBase.length; i++) {
              final entity = entitiesBase[i];

              final joinedWheres = <String, Where>{
                if (params.includeLikes?.wheres.isNotEmpty ?? false)
                  ...params.includeLikes!.wheres,
                'post_id': Where.eq(entity.id),
              };

              final joinedOffset = switch (params.includeLikes?.page != null) {
                false => 0,
                true => params.includeLikes!.page! - 1 == 0
                    ? 0
                    : params.includeLikes!.page! - 1,
              };

              final joinedLimit = params.includeLikes?.pageSize ?? 10;

              final joinedOrderBy =
                  switch (params.includeLikes?.orderBy != null) {
                false => null,
                true => params.includeLikes!.orderBy,
              };

              final joinedQuery =
                  'SELECT * FROM tb_likes WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}${joinedOrderBy != null ? ' ORDER BY ${joinedOrderBy.sql}' : ''} OFFSET $joinedOffset LIMIT $joinedLimit';

              final joinedParameters =
                  joinedWheres.values.map((w) => w.value).toList();

              final joinedCountQuery =
                  switch (params.includeLikes?.withCount ?? false) {
                false => null,
                true =>
                  'SELECT COUNT(*) FROM tb_likes WHERE ${joinedWheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}',
              };

              if (verbose) {
                print('-' * 80);

                print('QUERY: $joinedQuery');

                if (joinedCountQuery != null) {
                  print('COUNT QUERY: $joinedCountQuery');
                }

                print('PARAMETERS: $joinedParameters');

                print('-' * 80);
              }

              int? likesCount;

              final joinedResult = await tx.execute(
                joinedQuery,
                parameters: joinedParameters,
              );

              if (joinedCountQuery != null) {
                final joinedCountResult = await tx.execute(
                  joinedCountQuery,
                  parameters: joinedParameters,
                );

                if (joinedCountResult.isNotEmpty) {
                  likesCount = joinedCountResult.first.first as int;
                }
              }

              final joinedEntities = List<LikeEntity>.from(
                joinedResult.map(
                  (row) {
                    final [
                      String $id,
                      String $postId,
                      String $userId,
                      DateTime $createdAt,
                    ] = row as List;

                    return LikeEntity(
                      id: $id,
                      postId: $postId,
                      userId: $userId,
                      createdAt: $createdAt,
                    );
                  },
                ),
              );

              entitiesBase[i] = entity.copyWith(
                $likes: () => joinedEntities,
                $likesCount: () => likesCount,
              );
            }
          }

          return Pagination<PostEntity>(
            items: entitiesBase,
            total: entitiesBase.length,
            page: offset,
            pageSize: limit,
            hasNext: (offset + 1) * limit > count,
            hasPrevious: (offset + 1) > 0,
          );
        },
      );

      return Success(data);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> findOne({
    Where? id,
    Where? postId,
    Where? content,
    Where? userId,
    Where? createdAt,
    Where? updatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (postId != null) 'post_id': postId,
        if (content != null) 'content': content,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_posts WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('PostEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_posts WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> updateOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereContent,
    Where? whereUserId,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
    String? setPostId,
    String? setContent,
    String? setUserId,
    DateTime? setCreatedAt,
    DateTime? setUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereContent != null) 'content': whereContent,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setPostId != null) 'post_id': setPostId,
        if (setContent != null) 'content': setContent,
        if (setUserId != null) 'user_id': setUserId,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
        if (setUpdatedAt != null) 'updated_at': setUpdatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_posts SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> deleteOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereContent,
    Where? whereUserId,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereContent != null) 'content': whereContent,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_posts WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class FindManyPostParams {
  final Where? whereId;
  final Where? wherePostId;
  final Where? whereContent;
  final Where? whereUserId;
  final Where? whereCreatedAt;
  final Where? whereUpdatedAt;
  final IncludePostReplies? includeReplies;
  final IncludePostLikes? includeLikes;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;

  const FindManyPostParams({
    this.whereId,
    this.wherePostId,
    this.whereContent,
    this.whereUserId,
    this.whereCreatedAt,
    this.whereUpdatedAt,
    this.includeReplies,
    this.includeLikes,
    this.page,
    this.pageSize,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (wherePostId != null) 'post_id': wherePostId!,
        if (whereContent != null) 'content': whereContent!,
        if (whereUserId != null) 'user_id': whereUserId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt!,
        ...?includeReplies?.wheres,
        ...?includeLikes?.wheres,
      };
}

class IncludePostReplies {
  final Where? id;
  final Where? content;
  final Where? userId;
  final Where? createdAt;
  final Where? updatedAt;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;
  final bool? withCount;

  const IncludePostReplies({
    this.id,
    this.content,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.page,
    this.pageSize,
    this.orderBy,
    this.withCount,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (content != null) 'content': content!,
        if (userId != null) 'user_id': userId!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class IncludePostLikes {
  final Where? id;
  final Where? userId;
  final Where? createdAt;
  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;
  final bool? withCount;

  const IncludePostLikes({
    this.id,
    this.userId,
    this.createdAt,
    this.page,
    this.pageSize,
    this.orderBy,
    this.withCount,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (userId != null) 'user_id': userId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class LikesRepository {
  final Connection _conn;
  final bool verbose;

  const LikesRepository(this._conn, {this.verbose = false});

  AsyncResult<LikeEntity, Exception> insertOne({
    required String postId,
    required String userId,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_likes (post_id, user_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $postId, $userId');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [postId, userId],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<LikeEntity>, Exception> insertMany({
    required List<({String postId, String userId})> values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_likes (post_id, user_id) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 2)}, \$${1 + 1 + (index * 2)})').join(', ')} RETURNING *;';

      final parameters =
          values.map((v) => [v.postId, v.userId]).expand((v) => v).toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      final entities = List<LikeEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $postId,
              String $userId,
              DateTime $createdAt,
            ] = row as List;

            final entity = LikeEntity(
              id: $id,
              postId: $postId,
              userId: $userId,
              createdAt: $createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<Pagination<LikeEntity>, Exception> findMany(
      [FindManyLikeParams params = const FindManyLikeParams()]) async {
    try {
      final data = await _conn.runTx<Pagination<LikeEntity>>(
        (tx) async {
          final offset = switch (params.page != null) {
            false => 0,
            true => params.page! - 1 < 0 ? 0 : params.page! - 1,
          };

          final limit = params.pageSize ?? 10;

          final orderBy = switch (params.orderBy != null) {
            false => null,
            true => params.orderBy,
          };

          final baseQuery =
              'SELECT * FROM tb_likes${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''}${orderBy != null ? ' ORDER BY ${orderBy.sql}' : ''} OFFSET $offset LIMIT $limit;';

          final countQuery =
              'SELECT COUNT(*) FROM tb_likes${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''};';

          final baseParameters =
              params.wheres.values.map((w) => w.value).toList();

          if (verbose) {
            print('-' * 80);

            print('QUERY: $baseQuery');

            print('PARAMETERS: $baseParameters');

            print('-' * 80);
          }

          final resultBase = await tx.execute(
            baseQuery,
            parameters: baseParameters,
          );

          final resultCount = await tx.execute(
            countQuery,
            parameters: baseParameters,
          );

          final count = resultCount[0][0] as int;

          if (resultBase.isEmpty) {
            await tx.rollback();
            return Pagination<LikeEntity>(
              items: [],
              total: 0,
              page: offset,
              pageSize: limit,
              hasNext: false,
              hasPrevious: false,
            );
          }

          final entitiesBase = List<LikeEntity>.from(
            resultBase.map(
              (row) {
                final [
                  String id,
                  String postId,
                  String userId,
                  DateTime createdAt,
                ] = row as List;

                return LikeEntity(
                  id: id,
                  postId: postId,
                  userId: userId,
                  createdAt: createdAt,
                );
              },
            ),
          );

          return Pagination<LikeEntity>(
            items: entitiesBase,
            total: entitiesBase.length,
            page: offset,
            pageSize: limit,
            hasNext: (offset + 1) * limit > count,
            hasPrevious: (offset + 1) > 0,
          );
        },
      );

      return Success(data);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> findOne({
    Where? id,
    Where? postId,
    Where? userId,
    Where? createdAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (postId != null) 'post_id': postId,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_likes WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('LikeEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_likes WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> updateOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereUserId,
    Where? whereCreatedAt,
    String? setPostId,
    String? setUserId,
    DateTime? setCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setPostId != null) 'post_id': setPostId,
        if (setUserId != null) 'user_id': setUserId,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_likes SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> deleteOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereUserId,
    Where? whereCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_likes WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class FindManyLikeParams {
  final Where? whereId;
  final Where? wherePostId;
  final Where? whereUserId;
  final Where? whereCreatedAt;

  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;

  const FindManyLikeParams({
    this.whereId,
    this.wherePostId,
    this.whereUserId,
    this.whereCreatedAt,
    this.page,
    this.pageSize,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (wherePostId != null) 'post_id': wherePostId!,
        if (whereUserId != null) 'user_id': whereUserId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
      };
}

class FollowersRepository {
  final Connection _conn;
  final bool verbose;

  const FollowersRepository(this._conn, {this.verbose = false});

  AsyncResult<FollowerEntity, Exception> insertOne({
    required String followerId,
    required String followingId,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_followers (follower_id, following_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $followerId, $followingId');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [followerId, followingId],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<FollowerEntity>, Exception> insertMany({
    required List<({String followerId, String followingId})> values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_followers (follower_id, following_id) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 2)}, \$${1 + 1 + (index * 2)})').join(', ')} RETURNING *;';

      final parameters = values
          .map((v) => [v.followerId, v.followingId])
          .expand((v) => v)
          .toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      final entities = List<FollowerEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $followerId,
              String $followingId,
              DateTime $createdAt,
            ] = row as List;

            final entity = FollowerEntity(
              id: $id,
              followerId: $followerId,
              followingId: $followingId,
              createdAt: $createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<Pagination<FollowerEntity>, Exception> findMany(
      [FindManyFollowerParams params = const FindManyFollowerParams()]) async {
    try {
      final data = await _conn.runTx<Pagination<FollowerEntity>>(
        (tx) async {
          final offset = switch (params.page != null) {
            false => 0,
            true => params.page! - 1 < 0 ? 0 : params.page! - 1,
          };

          final limit = params.pageSize ?? 10;

          final orderBy = switch (params.orderBy != null) {
            false => null,
            true => params.orderBy,
          };

          final baseQuery =
              'SELECT * FROM tb_followers${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''}${orderBy != null ? ' ORDER BY ${orderBy.sql}' : ''} OFFSET $offset LIMIT $limit;';

          final countQuery =
              'SELECT COUNT(*) FROM tb_followers${params.wheres.isNotEmpty ? ' WHERE ${params.wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}' : ''};';

          final baseParameters =
              params.wheres.values.map((w) => w.value).toList();

          if (verbose) {
            print('-' * 80);

            print('QUERY: $baseQuery');

            print('PARAMETERS: $baseParameters');

            print('-' * 80);
          }

          final resultBase = await tx.execute(
            baseQuery,
            parameters: baseParameters,
          );

          final resultCount = await tx.execute(
            countQuery,
            parameters: baseParameters,
          );

          final count = resultCount[0][0] as int;

          if (resultBase.isEmpty) {
            await tx.rollback();
            return Pagination<FollowerEntity>(
              items: [],
              total: 0,
              page: offset,
              pageSize: limit,
              hasNext: false,
              hasPrevious: false,
            );
          }

          final entitiesBase = List<FollowerEntity>.from(
            resultBase.map(
              (row) {
                final [
                  String id,
                  String followerId,
                  String followingId,
                  DateTime createdAt,
                ] = row as List;

                return FollowerEntity(
                  id: id,
                  followerId: followerId,
                  followingId: followingId,
                  createdAt: createdAt,
                );
              },
            ),
          );

          return Pagination<FollowerEntity>(
            items: entitiesBase,
            total: entitiesBase.length,
            page: offset,
            pageSize: limit,
            hasNext: (offset + 1) * limit > count,
            hasPrevious: (offset + 1) > 0,
          );
        },
      );

      return Success(data);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> findOne({
    Where? id,
    Where? followerId,
    Where? followingId,
    Where? createdAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (followerId != null) 'follower_id': followerId,
        if (followingId != null) 'following_id': followingId,
        if (createdAt != null) 'created_at': createdAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_followers WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('FollowerEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_followers WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> updateOne({
    Where? whereId,
    Where? whereFollowerId,
    Where? whereFollowingId,
    Where? whereCreatedAt,
    String? setFollowerId,
    String? setFollowingId,
    DateTime? setCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereFollowerId != null) 'follower_id': whereFollowerId,
        if (whereFollowingId != null) 'following_id': whereFollowingId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setFollowerId != null) 'follower_id': setFollowerId,
        if (setFollowingId != null) 'following_id': setFollowingId,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_followers SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> deleteOne({
    Where? whereId,
    Where? whereFollowerId,
    Where? whereFollowingId,
    Where? whereCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereFollowerId != null) 'follower_id': whereFollowerId,
        if (whereFollowingId != null) 'following_id': whereFollowingId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_followers WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class FindManyFollowerParams {
  final Where? whereId;
  final Where? whereFollowerId;
  final Where? whereFollowingId;
  final Where? whereCreatedAt;

  final int? page;
  final int? pageSize;
  final OrderBy? orderBy;

  const FindManyFollowerParams({
    this.whereId,
    this.whereFollowerId,
    this.whereFollowingId,
    this.whereCreatedAt,
    this.page,
    this.pageSize,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (whereFollowerId != null) 'follower_id': whereFollowerId!,
        if (whereFollowingId != null) 'following_id': whereFollowingId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
      };
}
