// This file is generated by DSQL.
// Do not modify it manually.

import 'package:dsql/dsql.dart';
import 'dart:convert';

part 'entities.dart';

class DSQL {
  late final UsersRepository users;
  late final PostsRepository posts;
  late final LikesRepository likes;
  late final FollowersRepository followers;

  DSQL._(Connection conn, {bool verbose = false}) {
    users = UsersRepository(conn, verbose: verbose);
    posts = PostsRepository(conn, verbose: verbose);
    likes = LikesRepository(conn, verbose: verbose);
    followers = FollowersRepository(conn, verbose: verbose);
  }

  static Future<DSQL> open(String databaseURL, {bool verbose = false}) async {
    final uri = Uri.parse(databaseURL);
    final host = uri.host;
    final port = uri.hasPort ? uri.port : 5432;
    final username = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[0],
    };
    final password = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[1],
    };
    final database = switch (uri.pathSegments.isNotEmpty) {
      true => uri.pathSegments.first,
      false => throw Exception('Database name is required!'),
    };
    final sslMode = switch (uri.queryParameters['sslmode']) {
      'require' => SslMode.require,
      'verify-full' => SslMode.verifyFull,
      'disable' => SslMode.disable,
      _ => SslMode.disable,
    };
    final conn = await Connection.open(
      Endpoint(
        host: host,
        port: port,
        username: username,
        password: password,
        database: database,
      ),
      settings: ConnectionSettings(
        sslMode: sslMode,
      ),
    );

    return DSQL._(conn, verbose: verbose);
  }
}

class UsersRepository {
  final Connection _conn;
  final bool verbose;

  const UsersRepository(this._conn, {this.verbose = false});

  AsyncResult<UserEntity, Exception> insertOne(
      InsertOneUserParams params) async {
    try {
      final query =
          r'INSERT INTO tb_users (name, username, email, password) VALUES ($1, $2, $3, $4) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<UserEntity>, Exception> findMany([
    FindManyUserParams params = const FindManyUserParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_users$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<UserEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String name,
              String username,
              String email,
              String password,
              String? image,
              String? bio,
              String? website,
              DateTime createdAt,
              DateTime updatedAt,
            ] = row as List;

            final entity = UserEntity(
              id: id,
              name: name,
              username: username,
              email: email,
              password: password,
              image: image,
              bio: bio,
              website: website,
              createdAt: createdAt,
              updatedAt: updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByPK(
    String pk, {
    bool includeUserposts = false,
    bool includeUserlikes = false,
    bool includeFollower = false,
    bool includeFollowing = false,
  }) async {
    try {
      String query = r'SELECT * FROM tb_users WHERE id = $1 LIMIT 1;';

      if (includeUserposts) {
        query = r'''SELECT
  u.id as u_users_id,
  u.name as u_users_name,
  u.username as u_users_username,
  u.email as u_users_email,
  u.password as u_users_password,
  u.image as u_users_image,
  u.bio as u_users_bio,
  u.website as u_users_website,
  u.created_at as u_users_created_at,
  u.updated_at as u_users_updated_at,
  p.id as p_posts_id2,
  p.post_id as p_posts_post_id2,
  p.title as p_posts_title2,
  p.body as p_posts_body2,
  p.owner_id as p_posts_owner_id2,
  p.created_at as p_posts_created_at2,
  p.updated_at as p_posts_updated_at2
FROM
  tb_users u
JOIN
  tb_posts p
ON
  u.id = p.owner_id
WHERE
  u.id = $1;''';
      }

      if (includeUserlikes) {
        query = r'''SELECT
  u.id as u_users_id,
  u.name as u_users_name,
  u.username as u_users_username,
  u.email as u_users_email,
  u.password as u_users_password,
  u.image as u_users_image,
  u.bio as u_users_bio,
  u.website as u_users_website,
  u.created_at as u_users_created_at,
  u.updated_at as u_users_updated_at,
  l.id as l_likes_id2,
  l.post_id as l_likes_post_id2,
  l.user_id as l_likes_user_id2,
  l.created_at as l_likes_created_at2
FROM
  tb_users u
JOIN
  tb_likes l
ON
  u.id = l.user_id
WHERE
  u.id = $1;''';
      }

      if (includeFollower) {
        query = r'''SELECT
  u.id as u_users_id,
  u.name as u_users_name,
  u.username as u_users_username,
  u.email as u_users_email,
  u.password as u_users_password,
  u.image as u_users_image,
  u.bio as u_users_bio,
  u.website as u_users_website,
  u.created_at as u_users_created_at,
  u.updated_at as u_users_updated_at,
  f.id as f_followers_id2,
  f.follower_id as f_followers_follower_id2,
  f.following_id as f_followers_following_id2,
  f.created_at as f_followers_created_at2
FROM
  tb_users u
JOIN
  tb_followers f
ON
  u.id = f.follower_id
WHERE
  u.id = $1;''';
      }

      if (includeFollowing) {
        query = r'''SELECT
  u.id as u_users_id,
  u.name as u_users_name,
  u.username as u_users_username,
  u.email as u_users_email,
  u.password as u_users_password,
  u.image as u_users_image,
  u.bio as u_users_bio,
  u.website as u_users_website,
  u.created_at as u_users_created_at,
  u.updated_at as u_users_updated_at,
  f.id as f_followers_id2,
  f.follower_id as f_followers_follower_id2,
  f.following_id as f_followers_following_id2,
  f.created_at as f_followers_created_at2
FROM
  tb_users u
JOIN
  tb_followers f
ON
  u.id = f.following_id
WHERE
  u.id = $1;''';
      }

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      if (includeUserposts) {
        final [
          String id,
          String name,
          String username,
          String email,
          String password,
          String? image,
          String? bio,
          String? website,
          DateTime createdAt,
          DateTime updatedAt,
          ...
        ] = row as List;

        final userPosts = result.map(
          (r) {
            final [
              ...,
              String id,
              String? postId,
              String title,
              String body,
              String ownerId,
              DateTime createdAt,
              DateTime updatedAt,
            ] = r as List;

            return PostEntity(
              id: id,
              postId: postId,
              title: title,
              body: body,
              ownerId: ownerId,
              createdAt: createdAt,
              updatedAt: updatedAt,
            );
          },
        ).toList();

        final entity = UserEntity(
          id: id,
          name: name,
          username: username,
          email: email,
          password: password,
          image: image,
          bio: bio,
          website: website,
          createdAt: createdAt,
          updatedAt: updatedAt,
          userPosts: userPosts,
        );

        return Success(entity);
      }

      if (includeUserlikes) {
        final [
          String id,
          String name,
          String username,
          String email,
          String password,
          String? image,
          String? bio,
          String? website,
          DateTime createdAt,
          DateTime updatedAt,
          ...
        ] = row as List;

        final userLikes = result.map(
          (r) {
            final [
              ...,
              String id,
              String postId,
              String userId,
              DateTime createdAt,
            ] = r as List;

            return LikeEntity(
              id: id,
              postId: postId,
              userId: userId,
              createdAt: createdAt,
            );
          },
        ).toList();

        final entity = UserEntity(
          id: id,
          name: name,
          username: username,
          email: email,
          password: password,
          image: image,
          bio: bio,
          website: website,
          createdAt: createdAt,
          updatedAt: updatedAt,
          userLikes: userLikes,
        );

        return Success(entity);
      }

      if (includeFollower) {
        final [
          String id,
          String name,
          String username,
          String email,
          String password,
          String? image,
          String? bio,
          String? website,
          DateTime createdAt,
          DateTime updatedAt,
          ...
        ] = row as List;

        final followers = result.map(
          (r) {
            final [
              ...,
              String id,
              String followerId,
              String followingId,
              DateTime createdAt,
            ] = r as List;

            return FollowerEntity(
              id: id,
              followerId: followerId,
              followingId: followingId,
              createdAt: createdAt,
            );
          },
        ).toList();

        final entity = UserEntity(
          id: id,
          name: name,
          username: username,
          email: email,
          password: password,
          image: image,
          bio: bio,
          website: website,
          createdAt: createdAt,
          updatedAt: updatedAt,
          followers: followers,
        );

        return Success(entity);
      }

      if (includeFollowing) {
        final [
          String id,
          String name,
          String username,
          String email,
          String password,
          String? image,
          String? bio,
          String? website,
          DateTime createdAt,
          DateTime updatedAt,
          ...
        ] = row as List;

        final following = result.map(
          (r) {
            final [
              ...,
              String id,
              String followerId,
              String followingId,
              DateTime createdAt,
            ] = r as List;

            return FollowerEntity(
              id: id,
              followerId: followerId,
              followingId: followingId,
              createdAt: createdAt,
            );
          },
        ).toList();

        final entity = UserEntity(
          id: id,
          name: name,
          username: username,
          email: email,
          password: password,
          image: image,
          bio: bio,
          website: website,
          createdAt: createdAt,
          updatedAt: updatedAt,
          following: following,
        );

        return Success(entity);
      }

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByUsername(String unique) async {
    try {
      final query = r'SELECT * FROM tb_users WHERE username = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[unique]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [unique],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByEmail(String unique) async {
    try {
      final query = r'SELECT * FROM tb_users WHERE email = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[unique]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [unique],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> updateOne(
      UpdateOneUserParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_users SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> deleteOne(
      DeleteOneUserParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_users WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        String? $website,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        website: $website,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOneUserParams {
  final String name;
  final String username;
  final String email;
  final String password;

  const InsertOneUserParams({
    required this.name,
    required this.username,
    required this.email,
    required this.password,
  });

  List get indexedParams => [
        name,
        username,
        email,
        password,
      ];
}

class FindManyUserParams {
  final Where? id;
  final Where? name;
  final Where? username;
  final Where? email;
  final Where? password;
  final Where? image;
  final Where? bio;
  final Where? website;
  final Where? createdAt;
  final Where? updatedAt;
  final bool includeUserposts;
  final bool includeUserlikes;
  final bool includeFollower;
  final bool includeFollowing;
  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyUserParams({
    this.id,
    this.name,
    this.username,
    this.email,
    this.password,
    this.image,
    this.bio,
    this.website,
    this.createdAt,
    this.updatedAt,
    this.includeUserposts = false,
    this.includeUserlikes = false,
    this.includeFollower = false,
    this.includeFollowing = false,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (name != null) 'name': name!,
        if (username != null) 'username': username!,
        if (email != null) 'email': email!,
        if (password != null) 'password': password!,
        if (image != null) 'image': image!,
        if (bio != null) 'bio': bio!,
        if (website != null) 'website': website!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class UpdateOneUserParams {
  final Where? whereId;
  final Where? whereName;
  final Where? whereUsername;
  final Where? whereEmail;
  final Where? wherePassword;
  final Where? whereImage;
  final Where? whereBio;
  final Where? whereWebsite;
  final Where? whereCreatedAt;
  final Where? whereUpdatedAt;
  final String? name;
  final String? username;
  final String? email;
  final String? password;
  final String? image;
  final String? bio;
  final String? website;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const UpdateOneUserParams({
    this.whereId,
    this.whereName,
    this.whereUsername,
    this.whereEmail,
    this.wherePassword,
    this.whereImage,
    this.whereBio,
    this.whereWebsite,
    this.whereCreatedAt,
    this.whereUpdatedAt,
    this.name,
    this.username,
    this.email,
    this.password,
    this.image,
    this.bio,
    this.website,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (whereName != null) 'name': whereName!,
        if (whereUsername != null) 'username': whereUsername!,
        if (whereEmail != null) 'email': whereEmail!,
        if (wherePassword != null) 'password': wherePassword!,
        if (whereImage != null) 'image': whereImage!,
        if (whereBio != null) 'bio': whereBio!,
        if (whereWebsite != null) 'website': whereWebsite!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (name != null) 'name': name,
        if (username != null) 'username': username,
        if (email != null) 'email': email,
        if (password != null) 'password': password,
        if (image != null) 'image': image,
        if (bio != null) 'bio': bio,
        if (website != null) 'website': website,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };
}

class DeleteOneUserParams {
  final Where? id;
  final Where? name;
  final Where? username;
  final Where? email;
  final Where? password;
  final Where? image;
  final Where? bio;
  final Where? website;
  final Where? createdAt;
  final Where? updatedAt;

  const DeleteOneUserParams({
    this.id,
    this.name,
    this.username,
    this.email,
    this.password,
    this.image,
    this.bio,
    this.website,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (name != null) 'name': name!,
        if (username != null) 'username': username!,
        if (email != null) 'email': email!,
        if (password != null) 'password': password!,
        if (image != null) 'image': image!,
        if (bio != null) 'bio': bio!,
        if (website != null) 'website': website!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class PostsRepository {
  final Connection _conn;
  final bool verbose;

  const PostsRepository(this._conn, {this.verbose = false});

  AsyncResult<PostEntity, Exception> insertOne(
      InsertOnePostParams params) async {
    try {
      final query =
          r'INSERT INTO tb_posts (title, body, owner_id) VALUES ($1, $2, $3) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String id,
        String? postId,
        String title,
        String body,
        String ownerId,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: id,
        postId: postId,
        title: title,
        body: body,
        ownerId: ownerId,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<PostEntity>, Exception> findMany([
    FindManyPostParams params = const FindManyPostParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_posts$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<PostEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String? postId,
              String title,
              String body,
              String ownerId,
              DateTime createdAt,
              DateTime updatedAt,
            ] = row as List;

            final entity = PostEntity(
              id: id,
              postId: postId,
              title: title,
              body: body,
              ownerId: ownerId,
              createdAt: createdAt,
              updatedAt: updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> findByPK(
    String pk, {
    bool includePostreplies = false,
    bool includePostlikes = false,
  }) async {
    try {
      String query = r'SELECT * FROM tb_posts WHERE id = $1 LIMIT 1;';

      if (includePostreplies) {
        query = r'''SELECT
  p1.id as p1_posts_id,
  p1.post_id as p1_posts_post_id,
  p1.title as p1_posts_title,
  p1.body as p1_posts_body,
  p1.owner_id as p1_posts_owner_id,
  p1.created_at as p1_posts_created_at,
  p1.updated_at as p1_posts_updated_at,
  p2.id as p2_posts_id2,
  p2.post_id as p2_posts_post_id2,
  p2.title as p2_posts_title2,
  p2.body as p2_posts_body2,
  p2.owner_id as p2_posts_owner_id2,
  p2.created_at as p2_posts_created_at2,
  p2.updated_at as p2_posts_updated_at2
FROM
  tb_posts p1
JOIN
  tb_posts p2
ON
  p1.id = p2.post_id
WHERE
  p1.id = $1;''';
      }

      if (includePostlikes) {
        query = r'''SELECT
  p.id as p_posts_id,
  p.post_id as p_posts_post_id,
  p.title as p_posts_title,
  p.body as p_posts_body,
  p.owner_id as p_posts_owner_id,
  p.created_at as p_posts_created_at,
  p.updated_at as p_posts_updated_at,
  l.id as l_likes_id2,
  l.post_id as l_likes_post_id2,
  l.user_id as l_likes_user_id2,
  l.created_at as l_likes_created_at2
FROM
  tb_posts p
JOIN
  tb_likes l
ON
  p.id = l.post_id
WHERE
  p.id = $1;''';
      }

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_posts`!'));
      }

      final row = result.first;

      if (includePostreplies) {
        final [
          String id,
          String? postId,
          String title,
          String body,
          String ownerId,
          DateTime createdAt,
          DateTime updatedAt,
          ...
        ] = row as List;

        final postReplies = result.map(
          (r) {
            final [
              ...,
              String id,
              String? postId,
              String title,
              String body,
              String ownerId,
              DateTime createdAt,
              DateTime updatedAt,
            ] = r as List;

            return PostEntity(
              id: id,
              postId: postId,
              title: title,
              body: body,
              ownerId: ownerId,
              createdAt: createdAt,
              updatedAt: updatedAt,
            );
          },
        ).toList();

        final entity = PostEntity(
          id: id,
          postId: postId,
          title: title,
          body: body,
          ownerId: ownerId,
          createdAt: createdAt,
          updatedAt: updatedAt,
          postReplies: postReplies,
        );

        return Success(entity);
      }

      if (includePostlikes) {
        final [
          String id,
          String? postId,
          String title,
          String body,
          String ownerId,
          DateTime createdAt,
          DateTime updatedAt,
          ...
        ] = row as List;

        final postLikes = result.map(
          (r) {
            final [
              ...,
              String id,
              String postId,
              String userId,
              DateTime createdAt,
            ] = r as List;

            return LikeEntity(
              id: id,
              postId: postId,
              userId: userId,
              createdAt: createdAt,
            );
          },
        ).toList();

        final entity = PostEntity(
          id: id,
          postId: postId,
          title: title,
          body: body,
          ownerId: ownerId,
          createdAt: createdAt,
          updatedAt: updatedAt,
          postLikes: postLikes,
        );

        return Success(entity);
      }

      final [
        String id,
        String? postId,
        String title,
        String body,
        String ownerId,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: id,
        postId: postId,
        title: title,
        body: body,
        ownerId: ownerId,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> updateOne(
      UpdateOnePostParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_posts SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String id,
        String? postId,
        String title,
        String body,
        String ownerId,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: id,
        postId: postId,
        title: title,
        body: body,
        ownerId: ownerId,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> deleteOne(
      DeleteOnePostParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_posts WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $title,
        String $body,
        String $ownerId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        title: $title,
        body: $body,
        ownerId: $ownerId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOnePostParams {
  final String title;
  final String body;
  final String ownerId;

  const InsertOnePostParams({
    required this.title,
    required this.body,
    required this.ownerId,
  });

  List get indexedParams => [
        title,
        body,
        ownerId,
      ];
}

class FindManyPostParams {
  final Where? id;
  final Where? postId;
  final Where? title;
  final Where? body;
  final Where? ownerId;
  final Where? createdAt;
  final Where? updatedAt;
  final bool includePostreplies;
  final bool includePostlikes;
  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyPostParams({
    this.id,
    this.postId,
    this.title,
    this.body,
    this.ownerId,
    this.createdAt,
    this.updatedAt,
    this.includePostreplies = false,
    this.includePostlikes = false,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (title != null) 'title': title!,
        if (body != null) 'body': body!,
        if (ownerId != null) 'owner_id': ownerId!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class UpdateOnePostParams {
  final Where? whereId;
  final Where? wherePostId;
  final Where? whereTitle;
  final Where? whereBody;
  final Where? whereOwnerId;
  final Where? whereCreatedAt;
  final Where? whereUpdatedAt;
  final String? postId;
  final String? title;
  final String? body;
  final String? ownerId;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const UpdateOnePostParams({
    this.whereId,
    this.wherePostId,
    this.whereTitle,
    this.whereBody,
    this.whereOwnerId,
    this.whereCreatedAt,
    this.whereUpdatedAt,
    this.postId,
    this.title,
    this.body,
    this.ownerId,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (wherePostId != null) 'post_id': wherePostId!,
        if (whereTitle != null) 'title': whereTitle!,
        if (whereBody != null) 'body': whereBody!,
        if (whereOwnerId != null) 'owner_id': whereOwnerId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (postId != null) 'post_id': postId,
        if (title != null) 'title': title,
        if (body != null) 'body': body,
        if (ownerId != null) 'owner_id': ownerId,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };
}

class DeleteOnePostParams {
  final Where? id;
  final Where? postId;
  final Where? title;
  final Where? body;
  final Where? ownerId;
  final Where? createdAt;
  final Where? updatedAt;

  const DeleteOnePostParams({
    this.id,
    this.postId,
    this.title,
    this.body,
    this.ownerId,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (title != null) 'title': title!,
        if (body != null) 'body': body!,
        if (ownerId != null) 'owner_id': ownerId!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class LikesRepository {
  final Connection _conn;
  final bool verbose;

  const LikesRepository(this._conn, {this.verbose = false});

  AsyncResult<LikeEntity, Exception> insertOne(
      InsertOneLikeParams params) async {
    try {
      final query =
          r'INSERT INTO tb_likes (post_id, user_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String id,
        String postId,
        String userId,
        DateTime createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: id,
        postId: postId,
        userId: userId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<LikeEntity>, Exception> findMany([
    FindManyLikeParams params = const FindManyLikeParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_likes$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<LikeEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String postId,
              String userId,
              DateTime createdAt,
            ] = row as List;

            final entity = LikeEntity(
              id: id,
              postId: postId,
              userId: userId,
              createdAt: createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> findByPK(String pk) async {
    try {
      String query = r'SELECT * FROM tb_likes WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String id,
        String postId,
        String userId,
        DateTime createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: id,
        postId: postId,
        userId: userId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> updateOne(
      UpdateOneLikeParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_likes SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String id,
        String postId,
        String userId,
        DateTime createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: id,
        postId: postId,
        userId: userId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> deleteOne(
      DeleteOneLikeParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_likes WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOneLikeParams {
  final String postId;
  final String userId;

  const InsertOneLikeParams({
    required this.postId,
    required this.userId,
  });

  List get indexedParams => [
        postId,
        userId,
      ];
}

class FindManyLikeParams {
  final Where? id;
  final Where? postId;
  final Where? userId;
  final Where? createdAt;

  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyLikeParams({
    this.id,
    this.postId,
    this.userId,
    this.createdAt,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (userId != null) 'user_id': userId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class UpdateOneLikeParams {
  final Where? whereId;
  final Where? wherePostId;
  final Where? whereUserId;
  final Where? whereCreatedAt;
  final String? postId;
  final String? userId;
  final DateTime? createdAt;

  const UpdateOneLikeParams({
    this.whereId,
    this.wherePostId,
    this.whereUserId,
    this.whereCreatedAt,
    this.postId,
    this.userId,
    this.createdAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (wherePostId != null) 'post_id': wherePostId!,
        if (whereUserId != null) 'user_id': whereUserId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (postId != null) 'post_id': postId,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
      };
}

class DeleteOneLikeParams {
  final Where? id;
  final Where? postId;
  final Where? userId;
  final Where? createdAt;

  const DeleteOneLikeParams({
    this.id,
    this.postId,
    this.userId,
    this.createdAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (userId != null) 'user_id': userId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class FollowersRepository {
  final Connection _conn;
  final bool verbose;

  const FollowersRepository(this._conn, {this.verbose = false});

  AsyncResult<FollowerEntity, Exception> insertOne(
      InsertOneFollowerParams params) async {
    try {
      final query =
          r'INSERT INTO tb_followers (follower_id, following_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String id,
        String followerId,
        String followingId,
        DateTime createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: id,
        followerId: followerId,
        followingId: followingId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<FollowerEntity>, Exception> findMany([
    FindManyFollowerParams params = const FindManyFollowerParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_followers$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<FollowerEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String followerId,
              String followingId,
              DateTime createdAt,
            ] = row as List;

            final entity = FollowerEntity(
              id: id,
              followerId: followerId,
              followingId: followingId,
              createdAt: createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> findByPK(String pk) async {
    try {
      String query = r'SELECT * FROM tb_followers WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String id,
        String followerId,
        String followingId,
        DateTime createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: id,
        followerId: followerId,
        followingId: followingId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> updateOne(
      UpdateOneFollowerParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_followers SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String id,
        String followerId,
        String followingId,
        DateTime createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: id,
        followerId: followerId,
        followingId: followingId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> deleteOne(
      DeleteOneFollowerParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_followers WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOneFollowerParams {
  final String followerId;
  final String followingId;

  const InsertOneFollowerParams({
    required this.followerId,
    required this.followingId,
  });

  List get indexedParams => [
        followerId,
        followingId,
      ];
}

class FindManyFollowerParams {
  final Where? id;
  final Where? followerId;
  final Where? followingId;
  final Where? createdAt;

  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyFollowerParams({
    this.id,
    this.followerId,
    this.followingId,
    this.createdAt,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (followerId != null) 'follower_id': followerId!,
        if (followingId != null) 'following_id': followingId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class UpdateOneFollowerParams {
  final Where? whereId;
  final Where? whereFollowerId;
  final Where? whereFollowingId;
  final Where? whereCreatedAt;
  final String? followerId;
  final String? followingId;
  final DateTime? createdAt;

  const UpdateOneFollowerParams({
    this.whereId,
    this.whereFollowerId,
    this.whereFollowingId,
    this.whereCreatedAt,
    this.followerId,
    this.followingId,
    this.createdAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (whereFollowerId != null) 'follower_id': whereFollowerId!,
        if (whereFollowingId != null) 'following_id': whereFollowingId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (followerId != null) 'follower_id': followerId,
        if (followingId != null) 'following_id': followingId,
        if (createdAt != null) 'created_at': createdAt,
      };
}

class DeleteOneFollowerParams {
  final Where? id;
  final Where? followerId;
  final Where? followingId;
  final Where? createdAt;

  const DeleteOneFollowerParams({
    this.id,
    this.followerId,
    this.followingId,
    this.createdAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (followerId != null) 'follower_id': followerId!,
        if (followingId != null) 'following_id': followingId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}
