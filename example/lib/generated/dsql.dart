// This file is generated by DSQL.
// Do not modify it manually.

import 'package:dsql/dsql.dart';
import 'dart:convert';

part 'entities.dart';

class DSQL {
  late final UsersRepository users;
  late final PostsRepository posts;
  late final LikesRepository likes;
  late final FollowersRepository followers;

  DSQL._(Connection conn, {bool verbose = false}) {
    users = UsersRepository(conn, verbose: verbose);
    posts = PostsRepository(conn, verbose: verbose);
    likes = LikesRepository(conn, verbose: verbose);
    followers = FollowersRepository(conn, verbose: verbose);
  }

  static Future<DSQL> open(String databaseURL, {bool verbose = false}) async {
    final uri = Uri.parse(databaseURL);
    final host = uri.host;
    final port = uri.hasPort ? uri.port : 5432;
    final username = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[0],
    };
    final password = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[1],
    };
    final database = switch (uri.pathSegments.isNotEmpty) {
      true => uri.pathSegments.first,
      false => throw Exception('Database name is required!'),
    };
    final sslMode = switch (uri.queryParameters['sslmode']) {
      'require' => SslMode.require,
      'verify-full' => SslMode.verifyFull,
      'disable' => SslMode.disable,
      _ => SslMode.disable,
    };
    final conn = await Connection.open(
      Endpoint(
        host: host,
        port: port,
        username: username,
        password: password,
        database: database,
      ),
      settings: ConnectionSettings(
        sslMode: sslMode,
      ),
    );

    return DSQL._(conn, verbose: verbose);
  }
}

class UsersRepository {
  final Connection _conn;
  final bool verbose;

  const UsersRepository(this._conn, {this.verbose = false});

  AsyncResult<UserEntity, Exception> insertOne({
    required String name,
    required String username,
    required String email,
    required String password,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_users (name, username, email, password) VALUES ($1, $2, $3, $4) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $name, $username, $email, $password');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [name, username, email, password],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<UserEntity>, Exception> insertMany({
    required List<
            ({String name, String username, String email, String password})>
        values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_users (name, username, email, password) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 4)}, \$${1 + 1 + (index * 4)}, \$${2 + 1 + (index * 4)}, \$${3 + 1 + (index * 4)})').join(', ')} RETURNING *;';

      final parameters = values
          .map((v) => [v.name, v.username, v.email, v.password])
          .expand((v) => v)
          .toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      final entities = List<UserEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $name,
              String $username,
              String $email,
              String $password,
              String? $image,
              String? $bio,
              DateTime $createdAt,
              DateTime $updatedAt,
            ] = row as List;

            final entity = UserEntity(
              id: $id,
              name: $name,
              username: $username,
              email: $email,
              password: $password,
              image: $image,
              bio: $bio,
              createdAt: $createdAt,
              updatedAt: $updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<UserEntity>, Exception> findMany({
    Where? id,
    Where? name,
    Where? username,
    Where? email,
    Where? password,
    Where? image,
    Where? bio,
    Where? createdAt,
    Where? updatedAt,
    int? limit,
    int? offset,
    OrderBy? orderBy,
  }) async {
    try {
      String query = 'SELECT * FROM tb_users;';

      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (name != null) 'name': name,
        if (username != null) 'username': username,
        if (email != null) 'email': email,
        if (password != null) 'password': password,
        if (image != null) 'image': image,
        if (bio != null) 'bio': bio,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };

      if (wheres.isNotEmpty) {
        query =
            'SELECT * FROM tb_users WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}';
      }

      if (offset != null) {
        query += ' OFFSET $offset';
      }

      if (limit != null) {
        query += ' LIMIT $limit';
      }

      if (orderBy != null) {
        query += ' ORDER BY ${orderBy.sql}';
      }

      query += ';';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<UserEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $name,
              String $username,
              String $email,
              String $password,
              String? $image,
              String? $bio,
              DateTime $createdAt,
              DateTime $updatedAt,
            ] = row as List;

            return UserEntity(
              id: $id,
              name: $name,
              username: $username,
              email: $email,
              password: $password,
              image: $image,
              bio: $bio,
              createdAt: $createdAt,
              updatedAt: $updatedAt,
            );
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findOne({
    Where? id,
    Where? name,
    Where? username,
    Where? email,
    Where? password,
    Where? image,
    Where? bio,
    Where? createdAt,
    Where? updatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (name != null) 'name': name,
        if (username != null) 'username': username,
        if (email != null) 'email': email,
        if (password != null) 'password': password,
        if (image != null) 'image': image,
        if (bio != null) 'bio': bio,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_users WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('UserEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_users WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByUsername(String username) async {
    try {
      final query = r'SELECT * FROM tb_users WHERE username = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $username');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [username],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByEmail(String email) async {
    try {
      final query = r'SELECT * FROM tb_users WHERE email = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $email');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [email],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> updateOne({
    Where? whereId,
    Where? whereName,
    Where? whereUsername,
    Where? whereEmail,
    Where? wherePassword,
    Where? whereImage,
    Where? whereBio,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
    String? setName,
    String? setUsername,
    String? setEmail,
    String? setPassword,
    String? setImage,
    String? setBio,
    DateTime? setCreatedAt,
    DateTime? setUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereName != null) 'name': whereName,
        if (whereUsername != null) 'username': whereUsername,
        if (whereEmail != null) 'email': whereEmail,
        if (wherePassword != null) 'password': wherePassword,
        if (whereImage != null) 'image': whereImage,
        if (whereBio != null) 'bio': whereBio,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setName != null) 'name': setName,
        if (setUsername != null) 'username': setUsername,
        if (setEmail != null) 'email': setEmail,
        if (setPassword != null) 'password': setPassword,
        if (setImage != null) 'image': setImage,
        if (setBio != null) 'bio': setBio,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
        if (setUpdatedAt != null) 'updated_at': setUpdatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_users SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> deleteOne({
    Where? whereId,
    Where? whereName,
    Where? whereUsername,
    Where? whereEmail,
    Where? wherePassword,
    Where? whereImage,
    Where? whereBio,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereName != null) 'name': whereName,
        if (whereUsername != null) 'username': whereUsername,
        if (whereEmail != null) 'email': whereEmail,
        if (wherePassword != null) 'password': wherePassword,
        if (whereImage != null) 'image': whereImage,
        if (whereBio != null) 'bio': whereBio,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_users WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class PostsRepository {
  final Connection _conn;
  final bool verbose;

  const PostsRepository(this._conn, {this.verbose = false});

  AsyncResult<PostEntity, Exception> insertOne({
    required String content,
    required String userId,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_posts (content, user_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $content, $userId');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [content, userId],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<PostEntity>, Exception> insertMany({
    required List<({String content, String userId})> values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_posts (content, user_id) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 2)}, \$${1 + 1 + (index * 2)})').join(', ')} RETURNING *;';

      final parameters =
          values.map((v) => [v.content, v.userId]).expand((v) => v).toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      final entities = List<PostEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String? $postId,
              String $content,
              String $userId,
              DateTime $createdAt,
              DateTime $updatedAt,
            ] = row as List;

            final entity = PostEntity(
              id: $id,
              postId: $postId,
              content: $content,
              userId: $userId,
              createdAt: $createdAt,
              updatedAt: $updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<PostEntity>, Exception> findMany({
    Where? id,
    Where? postId,
    Where? content,
    Where? userId,
    Where? createdAt,
    Where? updatedAt,
    int? limit,
    int? offset,
    OrderBy? orderBy,
  }) async {
    try {
      String query = 'SELECT * FROM tb_posts;';

      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (postId != null) 'post_id': postId,
        if (content != null) 'content': content,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };

      if (wheres.isNotEmpty) {
        query =
            'SELECT * FROM tb_posts WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}';
      }

      if (offset != null) {
        query += ' OFFSET $offset';
      }

      if (limit != null) {
        query += ' LIMIT $limit';
      }

      if (orderBy != null) {
        query += ' ORDER BY ${orderBy.sql}';
      }

      query += ';';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<PostEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String? $postId,
              String $content,
              String $userId,
              DateTime $createdAt,
              DateTime $updatedAt,
            ] = row as List;

            return PostEntity(
              id: $id,
              postId: $postId,
              content: $content,
              userId: $userId,
              createdAt: $createdAt,
              updatedAt: $updatedAt,
            );
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> findOne({
    Where? id,
    Where? postId,
    Where? content,
    Where? userId,
    Where? createdAt,
    Where? updatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (postId != null) 'post_id': postId,
        if (content != null) 'content': content,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_posts WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('PostEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_posts WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> updateOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereContent,
    Where? whereUserId,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
    String? setPostId,
    String? setContent,
    String? setUserId,
    DateTime? setCreatedAt,
    DateTime? setUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereContent != null) 'content': whereContent,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setPostId != null) 'post_id': setPostId,
        if (setContent != null) 'content': setContent,
        if (setUserId != null) 'user_id': setUserId,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
        if (setUpdatedAt != null) 'updated_at': setUpdatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_posts SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> deleteOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereContent,
    Where? whereUserId,
    Where? whereCreatedAt,
    Where? whereUpdatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereContent != null) 'content': whereContent,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_posts WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $content,
        String $userId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        content: $content,
        userId: $userId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class LikesRepository {
  final Connection _conn;
  final bool verbose;

  const LikesRepository(this._conn, {this.verbose = false});

  AsyncResult<LikeEntity, Exception> insertOne({
    required String postId,
    required String userId,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_likes (post_id, user_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $postId, $userId');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [postId, userId],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<LikeEntity>, Exception> insertMany({
    required List<({String postId, String userId})> values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_likes (post_id, user_id) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 2)}, \$${1 + 1 + (index * 2)})').join(', ')} RETURNING *;';

      final parameters =
          values.map((v) => [v.postId, v.userId]).expand((v) => v).toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      final entities = List<LikeEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $postId,
              String $userId,
              DateTime $createdAt,
            ] = row as List;

            final entity = LikeEntity(
              id: $id,
              postId: $postId,
              userId: $userId,
              createdAt: $createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<LikeEntity>, Exception> findMany({
    Where? id,
    Where? postId,
    Where? userId,
    Where? createdAt,
    int? limit,
    int? offset,
    OrderBy? orderBy,
  }) async {
    try {
      String query = 'SELECT * FROM tb_likes;';

      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (postId != null) 'post_id': postId,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
      };

      if (wheres.isNotEmpty) {
        query =
            'SELECT * FROM tb_likes WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}';
      }

      if (offset != null) {
        query += ' OFFSET $offset';
      }

      if (limit != null) {
        query += ' LIMIT $limit';
      }

      if (orderBy != null) {
        query += ' ORDER BY ${orderBy.sql}';
      }

      query += ';';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<LikeEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $postId,
              String $userId,
              DateTime $createdAt,
            ] = row as List;

            return LikeEntity(
              id: $id,
              postId: $postId,
              userId: $userId,
              createdAt: $createdAt,
            );
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> findOne({
    Where? id,
    Where? postId,
    Where? userId,
    Where? createdAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (postId != null) 'post_id': postId,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_likes WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('LikeEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_likes WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> updateOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereUserId,
    Where? whereCreatedAt,
    String? setPostId,
    String? setUserId,
    DateTime? setCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setPostId != null) 'post_id': setPostId,
        if (setUserId != null) 'user_id': setUserId,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_likes SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> deleteOne({
    Where? whereId,
    Where? wherePostId,
    Where? whereUserId,
    Where? whereCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (wherePostId != null) 'post_id': wherePostId,
        if (whereUserId != null) 'user_id': whereUserId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_likes WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class FollowersRepository {
  final Connection _conn;
  final bool verbose;

  const FollowersRepository(this._conn, {this.verbose = false});

  AsyncResult<FollowerEntity, Exception> insertOne({
    required String followerId,
    required String followingId,
  }) async {
    try {
      final query =
          r'INSERT INTO tb_followers (follower_id, following_id) VALUES ($1, $2) RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $followerId, $followingId');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [followerId, followingId],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<FollowerEntity>, Exception> insertMany({
    required List<({String followerId, String followingId})> values,
  }) async {
    try {
      if (values.isEmpty) {
        return Error(Exception('Fail to insert: no data to insert!'));
      }

      final query =
          'INSERT INTO tb_followers (follower_id, following_id) VALUES ${values.indexedMap((index, value) => '(\$${0 + 1 + (index * 2)}, \$${1 + 1 + (index * 2)})').join(', ')} RETURNING *;';

      final parameters = values
          .map((v) => [v.followerId, v.followingId])
          .expand((v) => v)
          .toList();

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $parameters');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: parameters,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      if (result.length != values.length) {
        return Error(Exception('Fail to insert data on table `tb_followers`!'));
      }

      final entities = List<FollowerEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $followerId,
              String $followingId,
              DateTime $createdAt,
            ] = row as List;

            final entity = FollowerEntity(
              id: $id,
              followerId: $followerId,
              followingId: $followingId,
              createdAt: $createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<FollowerEntity>, Exception> findMany({
    Where? id,
    Where? followerId,
    Where? followingId,
    Where? createdAt,
    int? limit,
    int? offset,
    OrderBy? orderBy,
  }) async {
    try {
      String query = 'SELECT * FROM tb_followers;';

      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (followerId != null) 'follower_id': followerId,
        if (followingId != null) 'following_id': followingId,
        if (createdAt != null) 'created_at': createdAt,
      };

      if (wheres.isNotEmpty) {
        query =
            'SELECT * FROM tb_followers WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')}';
      }

      if (offset != null) {
        query += ' OFFSET $offset';
      }

      if (limit != null) {
        query += ' LIMIT $limit';
      }

      if (orderBy != null) {
        query += ' ORDER BY ${orderBy.sql}';
      }

      query += ';';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<FollowerEntity>.from(
        result.map(
          (row) {
            final [
              String $id,
              String $followerId,
              String $followingId,
              DateTime $createdAt,
            ] = row as List;

            return FollowerEntity(
              id: $id,
              followerId: $followerId,
              followingId: $followingId,
              createdAt: $createdAt,
            );
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> findOne({
    Where? id,
    Where? followerId,
    Where? followingId,
    Where? createdAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (id != null) 'id': id,
        if (followerId != null) 'follower_id': followerId,
        if (followingId != null) 'following_id': followingId,
        if (createdAt != null) 'created_at': createdAt,
      };

      if (wheres.isEmpty) {
        return Error(
            Exception('You need to pass at least one where parameter!'));
      }

      final query =
          'SELECT * FROM tb_followers WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('FollowerEntity not found'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> findByPK(String id) async {
    try {
      String query = r'SELECT * FROM tb_followers WHERE id = $1 LIMIT 1;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => $id');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [id],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> updateOne({
    Where? whereId,
    Where? whereFollowerId,
    Where? whereFollowingId,
    Where? whereCreatedAt,
    String? setFollowerId,
    String? setFollowingId,
    DateTime? setCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereFollowerId != null) 'follower_id': whereFollowerId,
        if (whereFollowingId != null) 'following_id': whereFollowingId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to update!'));
      }

      final parameters = <String, dynamic>{
        if (setFollowerId != null) 'follower_id': setFollowerId,
        if (setFollowingId != null) 'following_id': setFollowingId,
        if (setCreatedAt != null) 'created_at': setCreatedAt,
      };

      if (parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_followers SET ${parameters.entries.indexedMap((index, entry) => '${entry.key} = \$${index + 1}').join(', ')} WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1 + parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print(
            'PARAMS => ${parameters.values.join(', ')}, ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...parameters.values,
          ...wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<FollowerEntity, Exception> deleteOne({
    Where? whereId,
    Where? whereFollowerId,
    Where? whereFollowingId,
    Where? whereCreatedAt,
  }) async {
    try {
      final wheres = <String, Where>{
        if (whereId != null) 'id': whereId,
        if (whereFollowerId != null) 'follower_id': whereFollowerId,
        if (whereFollowingId != null) 'following_id': whereFollowingId,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt,
      };

      if (wheres.isEmpty) {
        return Error(Exception('No filters to delete!'));
      }

      final query =
          'DELETE FROM tb_followers WHERE ${wheres.entries.indexedMap((index, entry) => '${entry.key} ${entry.value.op} \$${index + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${wheres.values.map((w) => w.value).join(', ')}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_followers`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $followerId,
        String $followingId,
        DateTime $createdAt,
      ] = row as List;

      final entity = FollowerEntity(
        id: $id,
        followerId: $followerId,
        followingId: $followingId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}
