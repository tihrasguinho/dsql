import 'dart:convert';
import 'package:dsql/dsql.dart';

// ###########################################
// Generated by DSQL do not edit by hand!
// ###########################################

// UserEntity

class UserEntity {
  final String id;
  final String name;
  final String email;
  final String password;
  final String? image;
  final DateTime createdAt;
  final bool enabled;

  const UserEntity ({
      required this.id,
      required this.name,
      required this.email,
      required this.password,
      required this.image,
      required this.createdAt,
      required this.enabled,
  });

  Map<String, dynamic> toMap() => {
      'id': id,
      'name': name,
      'email': email,
      'password': password,
      'image': image,
      'created_at': createdAt,
      'enabled': enabled,
    };

  static UserEntity fromMap(Map<String, dynamic> map) => UserEntity(
      id: map['id'] as String,
      name: map['name'] as String,
      email: map['email'] as String,
      password: map['password'] as String,
      image: map['image'] as String,
      createdAt: map['created_at'] as DateTime,
      enabled: map['enabled'] as bool,
    );

  String toJson() => json.encode(toMap());

  static UserEntity fromJson(String source) => fromMap(json.decode(source));

  static UserEntity fromRow(List row) {
    final [id, name, email, password, image, createdAt, enabled] = row;

    return UserEntity(
      id: id,
      name: name,
      email: email,
      password: password,
      image: image,
      createdAt: createdAt,
      enabled: enabled,
    );
  }

  UserEntity copyWith({
    String? id,
    String? name,
    String? email,
    String? password,
    String? image,
    DateTime? createdAt,
    bool? enabled,
  }) {
    return UserEntity(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
      password: password ?? this.password,
      image: image ?? this.image,
      createdAt: createdAt ?? this.createdAt,
      enabled: enabled ?? this.enabled,
    );
  }

  @override
  int get hashCode => id.hashCode ^ name.hashCode ^ email.hashCode ^ password.hashCode ^ image.hashCode ^ createdAt.hashCode ^ enabled.hashCode;

  @override
  bool operator ==(covariant UserEntity other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;
    return id == other.id && name == other.name && email == other.email && password == other.password && image == other.image && createdAt == other.createdAt && enabled == other.enabled;
  }
}

// UserEntityRepository

class UserEntityRepository {
  final PostgreSQLConnection conn;

  UserEntityRepository(this.conn);

  Future<UserEntity> create({
    required name,
    required email,
    required password,
    required image,
  }) async {
    try {
      final create = await conn.query(
        'INSERT INTO tb_users (name, email, password, image) VALUES (@name, @email, @password, @image) RETURNING *',
        substitutionValues: {
          'name': name, 'email': email, 'password': password, 'image': image
        },   
      );

      return UserEntity.fromRow(create.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<List<UserEntity>> findMany({
    String? id,
    String? name,
    String? email,
    String? password,
    String? image,
    DateTime? createdAt,
    bool? enabled,
  }) async {
  try {
      PostgreSQLResult select;

      final where = <String, dynamic>{
        if (id != null) 'id': id, if (name != null) 'name': name, if (email != null) 'email': email, if (password != null) 'password': password, if (image != null) 'image': image, if (createdAt != null) 'created_at': createdAt, if (enabled != null) 'enabled': enabled
      };

      if (where.isNotEmpty) {
        select = await conn.query(
          'SELECT * FROM tb_users WHERE ${where.keys.join(' AND ')};',
          substitutionValues: where,
        );
      } else {
        select = await conn.query('SELECT * FROM tb_users;');
      }

      return select.map(UserEntity.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<UserEntity?> findById(String id) async {
    try {
      final query = await conn.query(
        'SELECT * FROM tb_users WHERE id = @id',
        substitutionValues: {
          'id': id,
        },
      );

      if (query.isEmpty) {
        return null;
      } else {
        return UserEntity.fromRow(query.first);
      }
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<UserEntity> update({
    String? name,
    String? email,
    String? password,
    String? image,
    DateTime? createdAt,
    bool? enabled,
  }) async {
    try {
      final params = <String, dynamic>{
        if (name != null) 'name': name, if (email != null) 'email': email, if (password != null) 'password': password, if (image != null) 'image': image, if (createdAt != null) 'created_at': createdAt, if (enabled != null) 'enabled': enabled
      };

      assert(params.isNotEmpty, 'At least one parameter must be provided!');

      final query = await conn.query(
        'UPDATE tb_users SET ${params.keys.map((e) => '$e: @$e').join(', ')} RETURNING *;',
        substitutionValues: params,
      );

      return UserEntity.fromRow(query.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }

  }

  Future<UserEntity> delete({
    String? id,
    String? name,
    String? email,
    String? password,
    String? image,
    DateTime? createdAt,
    bool? enabled,
  }) async {
    final params = <String, dynamic>{
      'id': id,
      'name': name,
      'email': email,
      'password': password,
      'image': image,
      'created_at': createdAt,
      'enabled': enabled,
    };

    assert(params.isNotEmpty, 'At least one parameter must be provided!');

    try {
      final query = await conn.query(
        'DELETE FROM tb_users WHERE ${params.keys.map((e) => '$e: @$e').join(' AND ')} RETURNING *;',
        substitutionValues: params,
      );

      return UserEntity.fromRow(query.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  
  }
}

/// [DSQL] Dart ORM
class DSQL {
  late final PostgreSQLConnection _conn;

  late final UserEntityRepository _userentityrepository;

  UserEntityRepository get user => _userentityrepository;

  DSQL(String host, int port, String database, {String? username, String? password, bool useSSL = false}) {
    _conn = PostgreSQLConnection(host, port, database, username: username, password: password, useSSL: useSSL);
    _userentityrepository = UserEntityRepository(_conn);
  }

  Future<void> initialize() async {
      await _conn.open();
  }
}
