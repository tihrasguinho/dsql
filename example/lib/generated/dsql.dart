// This file is generated by DSQL.
// Do not modify it manually.

import 'package:dsql/dsql.dart';
import 'dart:convert';

part 'entities.dart';

class DSQL {
  late final UserRepository users;
  late final PostRepository posts;
  late final LikeRepository likes;

  DSQL._(Connection conn, {bool verbose = false}) {
    users = UserRepository(conn, verbose: verbose);
    posts = PostRepository(conn, verbose: verbose);
    likes = LikeRepository(conn, verbose: verbose);
  }

  static Future<DSQL> open(String databaseURL, {bool verbose = false}) async {
    final uri = Uri.parse(databaseURL);
    final host = uri.host;
    final port = uri.hasPort ? uri.port : 5432;
    final username = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[0],
    };
    final password = switch (uri.hasAuthority && uri.userInfo.isNotEmpty) {
      false => null,
      true => uri.userInfo.split(':')[1],
    };
    final database = switch (uri.pathSegments.isNotEmpty) {
      true => uri.pathSegments.first,
      false => throw Exception('Database name is required!'),
    };
    final sslMode = switch (uri.queryParameters['sslmode']) {
      'require' => SslMode.require,
      'verify-full' => SslMode.verifyFull,
      'disable' => SslMode.disable,
      _ => SslMode.disable,
    };
    final conn = await Connection.open(
      Endpoint(
        host: host,
        port: port,
        username: username,
        password: password,
        database: database,
      ),
      settings: ConnectionSettings(
        sslMode: sslMode,
      ),
    );

    return DSQL._(conn, verbose: verbose);
  }
}

class UserRepository {
  final Connection _conn;
  final bool verbose;

  const UserRepository(this._conn, {this.verbose = false});

  AsyncResult<UserEntity, Exception> insertOne(
      InsertOneUserParams params) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(
            r'SQL => INSERT INTO tb_users (name, username, email, password) VALUES ($1, $2, $3, $4) RETURNING *;');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'INSERT INTO tb_users (name, username, email, password) VALUES ($1, $2, $3, $4) RETURNING *;',
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<UserEntity>, Exception> findMany([
    FindManyUserParams params = const FindManyUserParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_users$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<UserEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String name,
              String username,
              String email,
              String password,
              String? image,
              String? bio,
              String? website,
              DateTime createdAt,
              DateTime updatedAt,
            ] = row as List;

            final entity = UserEntity(
              id: id,
              name: name,
              username: username,
              email: email,
              password: password,
              image: image,
              bio: bio,
              website: website,
              createdAt: createdAt,
              updatedAt: updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByPK(String pk) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(r'SQL => SELECT * FROM tb_users WHERE id = $1 LIMIT 1;');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'SELECT * FROM tb_users WHERE id = $1 LIMIT 1;',
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByUsername(String unique) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(r'SQL => SELECT * FROM tb_users WHERE username = $1 LIMIT 1;');

        print('PARAMS => ${[unique]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'SELECT * FROM tb_users WHERE username = $1 LIMIT 1;',
        parameters: [unique],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> findByEmail(String unique) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(r'SQL => SELECT * FROM tb_users WHERE email = $1 LIMIT 1;');

        print('PARAMS => ${[unique]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'SELECT * FROM tb_users WHERE email = $1 LIMIT 1;',
        parameters: [unique],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> updateOne(
      UpdateOneUserParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_users SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String id,
        String name,
        String username,
        String email,
        String password,
        String? image,
        String? bio,
        String? website,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: id,
        name: name,
        username: username,
        email: email,
        password: password,
        image: image,
        bio: bio,
        website: website,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<UserEntity, Exception> deleteOne(
      DeleteOneUserParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_users WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_users`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $name,
        String $username,
        String $email,
        String $password,
        String? $image,
        String? $bio,
        String? $website,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = UserEntity(
        id: $id,
        name: $name,
        username: $username,
        email: $email,
        password: $password,
        image: $image,
        bio: $bio,
        website: $website,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOneUserParams {
  final String name;
  final String username;
  final String email;
  final String password;

  const InsertOneUserParams({
    required this.name,
    required this.username,
    required this.email,
    required this.password,
  });

  List get indexedParams => [
        name,
        username,
        email,
        password,
      ];
}

class FindManyUserParams {
  final Where? id;
  final Where? name;
  final Where? username;
  final Where? email;
  final Where? password;
  final Where? image;
  final Where? bio;
  final Where? website;
  final Where? createdAt;
  final Where? updatedAt;
  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyUserParams({
    this.id,
    this.name,
    this.username,
    this.email,
    this.password,
    this.image,
    this.bio,
    this.website,
    this.createdAt,
    this.updatedAt,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (name != null) 'name': name!,
        if (username != null) 'username': username!,
        if (email != null) 'email': email!,
        if (password != null) 'password': password!,
        if (image != null) 'image': image!,
        if (bio != null) 'bio': bio!,
        if (website != null) 'website': website!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class UpdateOneUserParams {
  final Where? whereId;
  final Where? whereName;
  final Where? whereUsername;
  final Where? whereEmail;
  final Where? wherePassword;
  final Where? whereImage;
  final Where? whereBio;
  final Where? whereWebsite;
  final Where? whereCreatedAt;
  final Where? whereUpdatedAt;
  final String? name;
  final String? username;
  final String? email;
  final String? password;
  final String? image;
  final String? bio;
  final String? website;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const UpdateOneUserParams({
    this.whereId,
    this.whereName,
    this.whereUsername,
    this.whereEmail,
    this.wherePassword,
    this.whereImage,
    this.whereBio,
    this.whereWebsite,
    this.whereCreatedAt,
    this.whereUpdatedAt,
    this.name,
    this.username,
    this.email,
    this.password,
    this.image,
    this.bio,
    this.website,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (whereName != null) 'name': whereName!,
        if (whereUsername != null) 'username': whereUsername!,
        if (whereEmail != null) 'email': whereEmail!,
        if (wherePassword != null) 'password': wherePassword!,
        if (whereImage != null) 'image': whereImage!,
        if (whereBio != null) 'bio': whereBio!,
        if (whereWebsite != null) 'website': whereWebsite!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (name != null) 'name': name,
        if (username != null) 'username': username,
        if (email != null) 'email': email,
        if (password != null) 'password': password,
        if (image != null) 'image': image,
        if (bio != null) 'bio': bio,
        if (website != null) 'website': website,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };
}

class DeleteOneUserParams {
  final Where? id;
  final Where? name;
  final Where? username;
  final Where? email;
  final Where? password;
  final Where? image;
  final Where? bio;
  final Where? website;
  final Where? createdAt;
  final Where? updatedAt;

  const DeleteOneUserParams({
    this.id,
    this.name,
    this.username,
    this.email,
    this.password,
    this.image,
    this.bio,
    this.website,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (name != null) 'name': name!,
        if (username != null) 'username': username!,
        if (email != null) 'email': email!,
        if (password != null) 'password': password!,
        if (image != null) 'image': image!,
        if (bio != null) 'bio': bio!,
        if (website != null) 'website': website!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class PostRepository {
  final Connection _conn;
  final bool verbose;

  const PostRepository(this._conn, {this.verbose = false});

  AsyncResult<PostEntity, Exception> insertOne(
      InsertOnePostParams params) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(
            r'SQL => INSERT INTO tb_posts (title, body, ownerId) VALUES ($1, $2, $3) RETURNING *;');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'INSERT INTO tb_posts (title, body, ownerId) VALUES ($1, $2, $3) RETURNING *;',
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String id,
        String? postId,
        String title,
        String body,
        String ownerId,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: id,
        postId: postId,
        title: title,
        body: body,
        ownerId: ownerId,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<PostEntity>, Exception> findMany([
    FindManyPostParams params = const FindManyPostParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_posts$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<PostEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String? postId,
              String title,
              String body,
              String ownerId,
              DateTime createdAt,
              DateTime updatedAt,
            ] = row as List;

            final entity = PostEntity(
              id: id,
              postId: postId,
              title: title,
              body: body,
              ownerId: ownerId,
              createdAt: createdAt,
              updatedAt: updatedAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> findByPK(String pk) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(r'SQL => SELECT * FROM tb_posts WHERE id = $1 LIMIT 1;');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'SELECT * FROM tb_posts WHERE id = $1 LIMIT 1;',
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String id,
        String? postId,
        String title,
        String body,
        String ownerId,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: id,
        postId: postId,
        title: title,
        body: body,
        ownerId: ownerId,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> updateOne(
      UpdateOnePostParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_posts SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String id,
        String? postId,
        String title,
        String body,
        String ownerId,
        DateTime createdAt,
        DateTime updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: id,
        postId: postId,
        title: title,
        body: body,
        ownerId: ownerId,
        createdAt: createdAt,
        updatedAt: updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<PostEntity, Exception> deleteOne(
      DeleteOnePostParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_posts WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_posts`!'));
      }

      final row = result.first;

      final [
        String $id,
        String? $postId,
        String $title,
        String $body,
        String $ownerId,
        DateTime $createdAt,
        DateTime $updatedAt,
      ] = row as List;

      final entity = PostEntity(
        id: $id,
        postId: $postId,
        title: $title,
        body: $body,
        ownerId: $ownerId,
        createdAt: $createdAt,
        updatedAt: $updatedAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOnePostParams {
  final String title;
  final String body;
  final String ownerId;

  const InsertOnePostParams({
    required this.title,
    required this.body,
    required this.ownerId,
  });

  List get indexedParams => [
        title,
        body,
        ownerId,
      ];
}

class FindManyPostParams {
  final Where? id;
  final Where? postId;
  final Where? title;
  final Where? body;
  final Where? ownerId;
  final Where? createdAt;
  final Where? updatedAt;
  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyPostParams({
    this.id,
    this.postId,
    this.title,
    this.body,
    this.ownerId,
    this.createdAt,
    this.updatedAt,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (title != null) 'title': title!,
        if (body != null) 'body': body!,
        if (ownerId != null) 'owner_id': ownerId!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class UpdateOnePostParams {
  final Where? whereId;
  final Where? wherePostId;
  final Where? whereTitle;
  final Where? whereBody;
  final Where? whereOwnerId;
  final Where? whereCreatedAt;
  final Where? whereUpdatedAt;
  final String? postId;
  final String? title;
  final String? body;
  final String? ownerId;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const UpdateOnePostParams({
    this.whereId,
    this.wherePostId,
    this.whereTitle,
    this.whereBody,
    this.whereOwnerId,
    this.whereCreatedAt,
    this.whereUpdatedAt,
    this.postId,
    this.title,
    this.body,
    this.ownerId,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (wherePostId != null) 'post_id': wherePostId!,
        if (whereTitle != null) 'title': whereTitle!,
        if (whereBody != null) 'body': whereBody!,
        if (whereOwnerId != null) 'owner_id': whereOwnerId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
        if (whereUpdatedAt != null) 'updated_at': whereUpdatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (postId != null) 'post_id': postId,
        if (title != null) 'title': title,
        if (body != null) 'body': body,
        if (ownerId != null) 'owner_id': ownerId,
        if (createdAt != null) 'created_at': createdAt,
        if (updatedAt != null) 'updated_at': updatedAt,
      };
}

class DeleteOnePostParams {
  final Where? id;
  final Where? postId;
  final Where? title;
  final Where? body;
  final Where? ownerId;
  final Where? createdAt;
  final Where? updatedAt;

  const DeleteOnePostParams({
    this.id,
    this.postId,
    this.title,
    this.body,
    this.ownerId,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (title != null) 'title': title!,
        if (body != null) 'body': body!,
        if (ownerId != null) 'owner_id': ownerId!,
        if (createdAt != null) 'created_at': createdAt!,
        if (updatedAt != null) 'updated_at': updatedAt!,
      };
}

class LikeRepository {
  final Connection _conn;
  final bool verbose;

  const LikeRepository(this._conn, {this.verbose = false});

  AsyncResult<LikeEntity, Exception> insertOne(
      InsertOneLikeParams params) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(
            r'SQL => INSERT INTO tb_likes (postId, userId) VALUES ($1, $2) RETURNING *;');

        print('PARAMS => ${params.indexedParams}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'INSERT INTO tb_likes (postId, userId) VALUES ($1, $2) RETURNING *;',
        parameters: params.indexedParams,
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to insert data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String id,
        String postId,
        String userId,
        DateTime createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: id,
        postId: postId,
        userId: userId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<List<LikeEntity>, Exception> findMany([
    FindManyLikeParams params = const FindManyLikeParams(),
  ]) async {
    try {
      final where = switch (params.wheres.isEmpty) {
        true => '',
        false =>
          ' WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')}',
      };

      final orderBy = switch (params.orderBy != null) {
        true => ' ORDER BY ${params.orderBy?.sql}',
        false => '',
      };

      final offset = switch (params.offset != null) {
        true => ' OFFSET ${params.offset}',
        false => '',
      };

      final limit = switch (params.limit != null) {
        true => ' LIMIT ${params.limit}',
        false => '',
      };

      final query = 'SELECT * FROM tb_likes$where$orderBy$offset$limit;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      final entities = List<LikeEntity>.from(
        result.map(
          (row) {
            final [
              String id,
              String postId,
              String userId,
              DateTime createdAt,
            ] = row as List;

            final entity = LikeEntity(
              id: id,
              postId: postId,
              userId: userId,
              createdAt: createdAt,
            );

            return entity;
          },
        ),
      );

      return Success(entities);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> findByPK(String pk) async {
    try {
      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print(r'SQL => SELECT * FROM tb_likes WHERE id = $1 LIMIT 1;');

        print('PARAMS => ${[pk]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        r'SELECT * FROM tb_likes WHERE id = $1 LIMIT 1;',
        parameters: [pk],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to find data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String id,
        String postId,
        String userId,
        DateTime createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: id,
        postId: postId,
        userId: userId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> updateOne(
      UpdateOneLikeParams params) async {
    try {
      if (params.parameters.isEmpty) {
        return Error(Exception('No data to update!'));
      }

      final query =
          'UPDATE tb_likes SET ${List.generate(params.parameters.length, (i) => '${params.parameters.keys.elementAt(i)} = \$${i + 1}').join(', ')} WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1 + params.parameters.length}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${[
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ]}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: [
          ...params.parameters.values,
          ...params.wheres.values.map((w) => w.value)
        ],
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to update data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String id,
        String postId,
        String userId,
        DateTime createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: id,
        postId: postId,
        userId: userId,
        createdAt: createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }

  AsyncResult<LikeEntity, Exception> deleteOne(
      DeleteOneLikeParams params) async {
    try {
      if (params.wheres.isEmpty) {
        return Error(Exception('No data to delete!'));
      }

      final query =
          'DELETE FROM tb_likes WHERE ${List.generate(params.wheres.length, (i) => '${params.wheres.keys.elementAt(i)} ${params.wheres.values.elementAt(i).op} \$${i + 1}').join(' AND ')} RETURNING *;';

      if (verbose) {
        print(
            '--------------------------------------------------------------------------------');

        print('SQL => $query');

        print('PARAMS => ${params.wheres.values.map((w) => w.value).toList()}');

        print(
            '--------------------------------------------------------------------------------');
      }

      final result = await _conn.execute(
        query,
        parameters: params.wheres.values.map((w) => w.value).toList(),
      );

      if (result.isEmpty) {
        return Error(Exception('Fail to delete data on table `tb_likes`!'));
      }

      final row = result.first;

      final [
        String $id,
        String $postId,
        String $userId,
        DateTime $createdAt,
      ] = row as List;

      final entity = LikeEntity(
        id: $id,
        postId: $postId,
        userId: $userId,
        createdAt: $createdAt,
      );

      return Success(entity);
    } on Exception catch (e) {
      return Error(e);
    }
  }
}

class InsertOneLikeParams {
  final String postId;
  final String userId;

  const InsertOneLikeParams({
    required this.postId,
    required this.userId,
  });

  List get indexedParams => [
        postId,
        userId,
      ];
}

class FindManyLikeParams {
  final Where? id;
  final Where? postId;
  final Where? userId;
  final Where? createdAt;
  final int? limit;
  final int? offset;
  final OrderBy? orderBy;

  const FindManyLikeParams({
    this.id,
    this.postId,
    this.userId,
    this.createdAt,
    this.limit,
    this.offset,
    this.orderBy,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (userId != null) 'user_id': userId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}

class UpdateOneLikeParams {
  final Where? whereId;
  final Where? wherePostId;
  final Where? whereUserId;
  final Where? whereCreatedAt;
  final String? postId;
  final String? userId;
  final DateTime? createdAt;

  const UpdateOneLikeParams({
    this.whereId,
    this.wherePostId,
    this.whereUserId,
    this.whereCreatedAt,
    this.postId,
    this.userId,
    this.createdAt,
  });

  Map<String, Where> get wheres => {
        if (whereId != null) 'id': whereId!,
        if (wherePostId != null) 'post_id': wherePostId!,
        if (whereUserId != null) 'user_id': whereUserId!,
        if (whereCreatedAt != null) 'created_at': whereCreatedAt!,
      };

  Map<String, dynamic> get parameters => {
        if (postId != null) 'post_id': postId,
        if (userId != null) 'user_id': userId,
        if (createdAt != null) 'created_at': createdAt,
      };
}

class DeleteOneLikeParams {
  final Where? id;
  final Where? postId;
  final Where? userId;
  final Where? createdAt;

  const DeleteOneLikeParams({
    this.id,
    this.postId,
    this.userId,
    this.createdAt,
  });

  Map<String, Where> get wheres => {
        if (id != null) 'id': id!,
        if (postId != null) 'post_id': postId!,
        if (userId != null) 'user_id': userId!,
        if (createdAt != null) 'created_at': createdAt!,
      };
}
